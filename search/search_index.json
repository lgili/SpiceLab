{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spicelab","text":"<p>spicelab is a modern interface for building SPICE netlists, orchestrating simulations across multiple engines, and post-processing results with familiar scientific Python tools.</p> <p></p> <p> </p>"},{"location":"#why-spicelab","title":"Why spicelab?","text":"<ul> <li>Unified orchestration \u2013 drive NGSpice, LTspice CLI, and Xyce from one API.</li> <li>Deterministic caching \u2013 hashed jobs avoid rerunning the same sweep or Monte Carlo trial.</li> <li>Typed circuits \u2013 ports, nets, and components are Python objects, not stringly-typed blobs.</li> <li>First-class data access \u2013 result handles expose xarray, pandas, and polars views with rich metadata.</li> <li>Docs &amp; examples \u2013 runnable scripts show how to wire circuits, sweeps, and metrics.</li> </ul>"},{"location":"#quick-preview","title":"Quick Preview","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\nfrom spicelab.core.types import AnalysisSpec\nfrom spicelab.engines import run_simulation\n\nc = Circuit(\"rc_demo\")\nV1 = Vdc(\"VIN\", 5.0)\nR1 = Resistor(\"R\", \"1k\")\nC1 = Capacitor(\"C\", \"100n\")\nfor comp in (V1, R1, C1):\n    c.add(comp)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\ntran = AnalysisSpec(\"tran\", {\"tstep\": \"10us\", \"tstop\": \"5ms\"})\nhandle = run_simulation(c, [tran], engine=\"ngspice\")\nprint(handle.dataset()[\"V(R)\"])\n</code></pre>"},{"location":"#explore","title":"Explore","text":"<ul> <li>Installation \u2013 set up UV/virtualenv and optional engines.</li> <li>Getting Started \u2013 build a circuit, run an analysis, inspect datasets.</li> <li>Concepts \u2013 circuits, components, ports, nets, handles.</li> <li>Engines \u2013 orchestration and caching model.</li> <li>Sweeps \u00b7 Monte Carlo \u2013 parametric workflows.</li> <li>Data I/O \u2013 ingestion of NGSpice/LTspice/Xyce RAW/PRN/CSV files.</li> <li>Cookbook \u2013 copy/paste snippets for metrics and data handling.</li> <li>Examples \u2013 runnable scripts with plots and figures.</li> </ul>"},{"location":"#package-status","title":"Package status","text":"<p>spicelab is actively evolving and currently offered as <code>spicelab==0.1.x</code> on PyPI. Breaking changes are documented in the changelog and reflected in these docs.</p>"},{"location":"ac-measurements/","title":"AC measurements","text":"<p>This page summarizes small-signal AC measurements available in <code>spicelab.analysis.measure</code> and how to consume results without optional DataFrame dependencies.</p>"},{"location":"ac-measurements/#available-specs","title":"Available specs","text":"<ul> <li>PhaseMarginSpec \u2014 Phase margin at unity-gain crossover of H = numerator/denominator. Returns PM = 180\u00b0 + angle(H) at |H| \u2248 1.</li> <li>GainBandwidthSpec \u2014 Unity-gain frequency (Hz) for H = numerator/denominator. For open-loop A, this is the GBW.</li> <li>GainMarginSpec \u2014 Gain margin (dB) at the phase crossing near \u2212180\u00b0. If no phase sample is within a tolerance band of \u2212180\u00b0, returns +\u221e.</li> </ul>"},{"location":"ac-measurements/#usage","title":"Usage","text":"<p>Evaluation returns a table. By default it uses Polars when available; for light environments (tests, scripts) you can request a plain Python result:</p> <pre><code>from spicelab.analysis.measure import (\n    measure,\n    PhaseMarginSpec, GainBandwidthSpec, GainMarginSpec,\n)\n\nrows = measure(\n    ds,\n    [\n        PhaseMarginSpec(name=\"pm\", numerator=\"vout\", denominator=\"vin\"),\n        GainBandwidthSpec(name=\"gbw\", numerator=\"vout\", denominator=\"vin\"),\n        GainMarginSpec(name=\"gm\", numerator=\"vout\", denominator=\"vin\", tolerance_deg=15.0),\n    ],\n    return_as=\"python\",\n)\n# rows is a list[dict]\nrows_by_name = {r[\"measure\"]: r for r in rows}\npm_deg = rows_by_name[\"pm\"][\"value\"]\ngbw_hz = rows_by_name[\"gbw\"][\"value\"]\ngm_db = rows_by_name[\"gm\"][\"value\"]\n</code></pre>"},{"location":"ac-measurements/#notes","title":"Notes","text":"<ul> <li>The extractor preserves complex values when available (AC analysis), ensuring accurate magnitude and phase computations.</li> <li>Tolerance for <code>GainMarginSpec</code> defaults to \u00b115\u00b0 around \u2212180\u00b0; adjust via <code>tolerance_deg</code> to match your sweep resolution.</li> <li>If you prefer a DataFrame, omit <code>return_as</code> and ensure <code>polars</code> is installed; you\u2019ll get a <code>polars.DataFrame</code> with the same columns.</li> </ul>"},{"location":"ac-stability/","title":"AC stability (placeholder)","text":"<p>The dedicated AC stability guide is being refreshed to align with the new measurement helpers (<code>GainSpec</code>, <code>OvershootSpec</code>, <code>SettlingTimeSpec</code>).</p> <p>In the meantime, check the Monte Carlo and Cookbook pages for snippets that demonstrate <code>.meas</code>-style metrics on <code>ResultHandle</code> datasets.</p>"},{"location":"api-reference/","title":"API reference guidance","text":"<p>Documentation for public modules is generated with <code>mkdocstrings</code>. To expose new API pages:</p> <ol> <li>Add a Markdown file under <code>docs/reference/</code>.</li> <li>Place a directive such as <code>::: spicelab.analysis</code> in the file.</li> <li>Run <code>mkdocs build</code> to verify imports succeed (install the package in editable    mode so mkdocstrings can import it).</li> </ol> <p>Keep exports stable and prefer documenting the orchestrator and core component APIs (<code>spicelab.analysis</code>, <code>spicelab.core</code>, <code>spicelab.engines</code>, <code>spicelab.io</code>).</p>"},{"location":"changelog-m6/","title":"M6 Wrap-up","text":"<p>This milestone focused on unifying the branding to \"spicelab\", improving notebook UX, and hardening typing and CI hooks.</p> <p>Highlights:</p> <ul> <li>Branding: updated README, docs content, and site name to \"spicelab\".</li> <li>Notebooks: added six English tutorials covering setup, sweeps, Monte Carlo, viz/widgets, and the DSL builder.</li> <li>Notebook plotting: improved robustness with a lightweight FigureWidget shim when ipywidgets/plotly aren't fully available.</li> <li>Tooling: resolved pre-commit failures (ruff/mypy), added type hints, and updated config for optional stubs.</li> <li>Tests: targeted tests for viz wrappers; added smoke tests for circuit tables.</li> </ul> <p>Next:</p> <ul> <li>Integrate notebooks more deeply (optional plugin) or continue linking directly.</li> <li>Start M7 scope.</li> </ul>"},{"location":"cli-ci/","title":"CLI and CI guide","text":""},{"location":"cli-ci/#spicelab-scripts-are-regular-python-modules-most-of-them-print-summary","title":"spicelab scripts are regular Python modules. Most of them print summary","text":"<p>information and optionally write PNG/CSV files next to the script. None of them require custom CLI flags any more \u2014 use environment variables (<code>SPICELAB_ENGINE</code>) if you want to force a particular simulator.</p>"},{"location":"cli-ci/#running-examples-in-ci","title":"Running examples in CI","text":"<ul> <li>Execute scripts with <code>uv run --active python examples/&lt;script&gt;.py</code>. Use a   temporary working directory when you want to capture artefacts.</li> <li>Cache directories created by the orchestrator (default <code>.spicelab_cache</code>) can   be retained between CI runs to avoid re-simulating identical sweeps.</li> <li>If you need to guarantee that a script does not invoke a real simulator,   temporarily patch <code>spicelab.engines.factory.create_simulator</code> with a stub, as   shown in the unit tests (<code>tests/test_engine_multi_parity.py</code>).</li> </ul>"},{"location":"cli-ci/#example-pytest-snippet","title":"Example pytest snippet","text":"<pre><code>import os\nimport subprocess\n\n\ndef test_rc_tran_smoke(tmp_path):\n    env = {\"SPICELAB_ENGINE\": \"ngspice\", **os.environ}\n    subprocess.run(\n        [\"uv\", \"run\", \"--active\", \"python\", \"examples/rc_tran.py\"],\n        cwd=tmp_path,\n        env=env,\n        check=True,\n    )\n</code></pre> <p>Swap <code>examples/rc_tran.py</code> for any other script you need to exercise.</p>"},{"location":"cli-ci/#spicelab-measure-raw-jsoncsv","title":"spicelab-measure (RAW -&gt; JSON/CSV)","text":"<p>Use the built-in CLI to compute AC and/or TRAN measurements from an NGSpice <code>.raw</code> file and export JSON or CSV.</p> <p>Examples:</p> <pre><code># AC + TRAN, JSON on stdout\nspicelab-measure path/to/ac_or_tran.raw --ac --tran --num \"V(out)\" --den \"V(in)\" --signal \"V(out)\" --f0 1e3 --format json\n\n# TRAN only, CSV to file\nspicelab-measure path/to/tran.raw --tran --signal \"V(out)\" --f0 1e3 --format csv --out metrics.csv\n</code></pre> <p>Columns include the measurement fields and values; JSON uses a list of dicts compatible with Python consumption.</p> <p>Tips:</p> <ul> <li>Discover available variables with:</li> </ul> <p><code>bash   spicelab-measure path/to/file.raw --list-signals --format csv</code></p> <ul> <li>Include dtype and axis when listing signals:</li> </ul> <p><code>bash   spicelab-measure path/to/file.raw --list-signals --list-details --format csv</code></p> <ul> <li>Print just the CSV schema (columns) for the selected metrics:</li> </ul> <p><code>bash   spicelab-measure path/to/file.raw --ac --format schema --num \"V(out)\" --den \"V(in)\"</code></p> <p>If a provided <code>--num</code>, <code>--den</code>, or <code>--signal</code> is invalid, the CLI shows suggestions based on available names.</p> <p>Schema and column ordering:</p> <ul> <li><code>--format schema</code> prints only the header (CSV columns) and does not execute any measurement logic. This makes it safe for CI checks or planning downstream pipelines.</li> <li>Column order is stable and sanitized:</li> <li>Core fields first: <code>measure,type,value,units</code></li> <li>Then known fields depending on selected metrics, e.g. AC: <code>freq,numerator,denominator,tolerance_deg</code>; TRAN: <code>signal,harmonics,f0,low_pct,high_pct,sinad_db</code>.</li> <li>Remaining fields are sorted by sanitized name for stability.</li> <li>Header names are sanitized (whitespace/newlines collapsed to <code>_</code> and CR/LF stripped) to avoid CSV header artifacts from unusual RAW keys.</li> </ul> <p>Quick checks:</p> <pre><code># AC schema (using fixture paths in this repo)\nuv run --active python -m spicelab.cli.measure tests/fixtures/rc_ac_ng.raw --ac --num \"V(out)\" --den \"I(R1)\" --format schema\n\n# List signals with details\nuv run --active python -m spicelab.cli.measure tests/fixtures/rc_ac_ng.raw --list-signals --list-details --format csv\n</code></pre>"},{"location":"cli-ci/#orchestrator-measurements-pipeline","title":"Orchestrator + measurements pipeline","text":"<p>You can run sweeps with the orchestrator and aggregate measurements per run:</p> <pre><code>from spicelab.analysis import run_and_measure, PhaseMarginSpec, GainBandwidthSpec, GainMarginSpec\nfrom spicelab.orchestrator import Job\nfrom spicelab.core.types import AnalysisSpec, SweepSpec\n\njob = Job(\n  circuit=your_circuit,\n  analyses=[AnalysisSpec(\"ac\", {\"sweep_type\": \"dec\", \"n\": 20, \"fstart\": 10, \"fstop\": 1e6})],\n  sweep=SweepSpec(variables={\"R1\": [1e3, 2e3, 4e3]}),\n)\n\nrows = run_and_measure(\n  job,\n  [\n    PhaseMarginSpec(name=\"pm\", numerator=\"V(out)\", denominator=\"V(in)\"),\n    GainBandwidthSpec(name=\"gbw\", numerator=\"V(out)\", denominator=\"V(in)\"),\n    GainMarginSpec(name=\"gm\", numerator=\"V(out)\", denominator=\"V(in)\"),\n  ],\n  return_as=\"python\",\n)\n</code></pre> <p>Each row includes the measurement fields plus the sweep parameters (prefixed as <code>param_&lt;name&gt;</code> by default). For a Polars DataFrame instead, pass <code>return_as=\"polars\"</code>.</p> <p>CSV exports in examples/orchestrator scripts follow the same stable ordering rules used by the CLI:</p> <ul> <li><code>param_*</code> columns come first (sorted).</li> <li>Measurement fields are ordered using the same helper as the CLI.</li> <li>Headers are sanitized to remove CR/LF and collapse whitespace to <code>_</code>.</li> </ul>"},{"location":"components-library/","title":"Component library","text":"<p>An updated component library reference is coming soon. For now, browse <code>spicelab/core/components.py</code> and the <code>docs/components.md</code> quick tour for examples of resistors, capacitors, controlled sources, ideal op-amps, and the analog multiplexer.</p> <p>If you add custom components, register them in your own module and expose them ahead of simulation. A future release will include full documentation and typed registries for custom factories.</p>"},{"location":"components-quickstart/","title":"Components quick reference","text":"<p>Short aliases for the most common spicelab components:</p> Helper Component Example <code>R(value)</code> <code>Resistor</code> <code>R(\"10k\")</code> <code>C(value)</code> <code>Capacitor</code> <code>C(\"100n\")</code> <code>L(value)</code> <code>Inductor</code> <code>L(1e-3)</code> <code>V(value)</code> <code>Vdc</code> <code>V(5.0)</code> <code>I(value)</code> <code>Idc</code> <code>I(1e-3)</code> <code>VP(...)</code> <code>Vpulse</code> <code>VP(0, 5, td=0, tr=1e-6, tf=1e-6, pw=1e-3, per=2e-3)</code> <code>VSIN(...)</code> <code>Vsin</code> <code>VSIN(vdc=0, vac=1, freq=1e3)</code> <code>VPWL(points)</code> <code>Vpwl</code> <code>VPWL([(0,0), (1e-3,5)])</code> <code>OA(gain)</code> <code>OpAmpIdeal</code> <code>OA(1e6)</code> <code>E(ref, gain)</code> <code>VCVS</code> <code>E(\"1\", 2.0)</code> <code>G(ref, gm)</code> <code>VCCS</code> <code>G(\"1\", 1e-3)</code> <p>All helpers come from <code>spicelab.core.components</code>. They return fully fledged component instances that you add to a <code>Circuit</code> and connect via ports.</p> <p>Remember to add any required <code>.model</code> directives for diodes, BJTs, switches, or your own subcircuits:</p> <pre><code>c.add_directive(\".model SWMOD VSWITCH(Ron=1 Roff=1Meg Vt=2 Vh=0.5)\")\n</code></pre>"},{"location":"components/","title":"Components Overview","text":"<p>spicelab ships a typed component library. Each component exposes <code>ports</code>, participates in the circuit connectivity graph, and knows how to format its SPICE card when you call <code>Circuit.build_netlist()</code>.</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\n\nc = Circuit(\"rc\")\nV1 = Vdc(\"VIN\", 5.0)\nR1 = Resistor(\"R\", \"1k\")\nC1 = Capacitor(\"C\", \"100n\")\nfor comp in (V1, R1, C1):\n    c.add(comp)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\nprint(c.build_netlist())\n</code></pre>"},{"location":"components/#circuitbuilder-dsl","title":"CircuitBuilder DSL","text":"<p>For larger circuits the iterative <code>add</code>/<code>connect</code> dance can get noisy. The <code>CircuitBuilder</code> DSL shipped in <code>spicelab.dsl.builder</code> lets you declare nets, drop parts, and wire busses inline:</p> <pre><code>from spicelab.dsl import CircuitBuilder\n\nbuilder = CircuitBuilder(\"pi_filter\")\nVIN, VOUT, GND = builder.net(\"VIN\"), builder.net(\"VOUT\"), builder.gnd()\nbus = builder.bus(\"VIN\", \"MID\", \"VOUT\")\n\nbuilder.vdc(\"VIN\", VIN, GND, 5.0)\nbuilder.resistor(\"R1\", VIN, bus.MID, \"220\")\nbuilder.capacitor(\"C1\", bus.MID, GND, \"10u\")\nbuilder.inductor(\"L1\", bus.MID, VOUT, \"47u\")\nbuilder.capacitor(\"C2\", VOUT, GND, \"22u\")\n\ncircuit = builder.circuit\nprint(circuit.build_netlist())\n</code></pre> <p>Nets can be named, duplicated, or grouped in busses. Every shorthand accepts either explicit reference designators (<code>\"R1\"</code>) or lets the builder auto-number using prefixes (<code>builder.resistor(\"R\", ...)</code>).</p>"},{"location":"components/#circuit-context-dsl-parameters-directives","title":"Circuit context DSL (parameters &amp; directives)","text":"<p>For scripts that lean heavily on <code>.param</code>, <code>.option</code>, and other control statements, try the lightweight context-based DSL:</p> <pre><code>from spicelab.dsl import Circuit, Net, Param, Option, TEMP, IC, Directive, R, V\n\nwith Circuit(\"rc_control\") as ctx:\n    vin = Net(\"vin\")\n    vout = Net(\"vout\")\n    gnd = Net(\"0\")\n\n    Param(\"Rval\", \"10k\")                 # -&gt; .param Rval=10k\n    Option(reltol=1e-3, abstol=1e-6)       # -&gt; .option reltol=0.001 abstol=1e-06\n    TEMP(27, 85)                           # -&gt; .temp 27 85\n    IC(vout=\"0\")                          # -&gt; .ic V(vout)=0\n    Directive(\".save V(vout)\")            # raw escape hatch (validated)\n\n    V(\"VIN\", vin, gnd, 5.0)\n    R(\"R1\", vin, vout, \"Rval\")\n\ncircuit = ctx.circuit\nprint(circuit.build_netlist())\n</code></pre> <p>All helpers validate the expressions before emitting them into the netlist. In particular <code>Param</code>, <code>Option</code>, <code>TEMP</code>, and <code>IC</code> use a safe expression normaliser that accepts numbers, engineering suffixes (<code>10k</code>, <code>100n</code>), basic math symbols, and references to previously declared parameters. The <code>Directive</code> helper keeps a \u201csafe\u201d mode on by default\u2014lines must start with a dot. Pass <code>safe=False</code> to drop the guard when you really need arbitrary text.</p> <p>The context manager stores the underlying <code>spicelab.core.circuit.Circuit</code> in <code>ctx.circuit</code>, so you can continue using all low-level APIs. Component shortcuts (<code>R</code>, <code>C</code>, <code>L</code>, <code>V</code>) simply instantiate the typed components and wire them to the given nets (strings or <code>Net</code> objects). Use <code>spicelab.dsl.place(...)</code> to register any other component manually.</p>"},{"location":"components/#common-parts","title":"Common parts","text":"Component Helper Notes <code>Resistor(ref, value)</code> <code>R(value)</code> Value accepts numbers or suffixed strings (<code>\"1k\"</code>, <code>\"10m\"</code>). <code>Capacitor(ref, value)</code> <code>C(value)</code> Two-terminal capacitor. <code>Inductor(ref, value)</code> <code>L(value)</code> Two-terminal inductor. <code>Vdc</code>, <code>Idc</code> <code>V</code>, <code>I</code> Independent DC sources. <code>Vpulse</code>, <code>Ipulse</code> <code>VP</code>, <code>IP</code> Pulse sources. <code>Vsin</code>, <code>Isin</code> <code>VSIN</code>, <code>ISIN</code> Sine sources. <code>Vpwl</code>, <code>Ipwl</code> <code>VPWL</code>, <code>IPWL</code> Piecewise-linear sources. <code>VA</code>, <code>IA</code> Small-signal AC helpers. <code>VCVS</code>, <code>VCCS</code>, <code>CCCS</code>, <code>CCVS</code> <code>E</code>, <code>G</code>, <code>F</code>, <code>H</code> Controlled sources. <code>OpAmpIdeal</code> <code>OA</code> Three-port ideal op-amp (VCVS). <code>AnalogMux8</code> \u2013 8:1 analog multiplexer with optional enable pins. <p>All helpers live in <code>spicelab.core.components</code>. Import only what you need, or use the shorthand constructors (<code>R</code>, <code>C</code>, <code>V</code>, etc.) for quick sketches.</p>"},{"location":"components/#directives-models","title":"Directives &amp; models","text":"<p>When you need SPICE directives (e.g. <code>.model</code>, <code>.include</code>) call <code>circuit.add_directive(...)</code>. Components such as <code>Diode</code> or <code>AnalogMux8</code> expose convenience booleans to emit models automatically; check their docstrings for arguments.</p> <p>Example:</p> <pre><code>from spicelab.core.components import Diode\n\nD1 = Diode(\"D1\", model=\"DFAST\")\nc.add_directive(\".model DFAST D(Is=1e-14 Rs=0.5)\")\n</code></pre>"},{"location":"components/#visual-preview","title":"Visual preview","text":"<p>Use <code>Circuit.summary()</code> to inspect connectivity and <code>Circuit.render_svg()</code> to export a quick Graphviz diagram (see <code>examples/circuit_preview.py</code>).</p> <p><code>Circuit.summary_table()</code> and <code>Circuit.connectivity_dataframe()</code> expose the same data as a plain-text table or pandas <code>DataFrame</code>. These helpers power the interactive widgets below and make it easy to drop connectivity checks into a notebook or CLI report.</p>"},{"location":"components/#notebook-helpers","title":"Notebook helpers","text":"<p>Install the <code>viz</code> extra to bring in Plotly and ipywidgets:</p> <pre><code>pip install circuit-toolkit[viz]\n</code></pre> <p>From a notebook you can embed circuit tables and plot Monte Carlo datasets via <code>spicelab.viz.notebook</code>:</p> <pre><code>from spicelab.viz.notebook import connectivity_widget, dataset_plot_widget\n\nconnectivity_widget(circuit)  # interactive component/net browser\n\nfig_widget = dataset_plot_widget(dataset)\nfig_widget  # display a FigureWidget with selector dropdowns\n</code></pre> <p>Widgets fall back gracefully when optional dependencies are missing and play nicely alongside the DSL builder for rapid prototyping inside VS Code or Jupyter.</p> <p>For full workflows (sweeps, Monte Carlo, engines) read the dedicated guides \u2013 components slot directly into those orchestration helpers.</p>"},{"location":"concepts/","title":"Core concepts","text":"<p>spicelab revolves around a few simple abstractions:</p> <ul> <li>Ports \u2013 typed terminals on components.</li> <li>Nets \u2013 named nodes (use <code>GND</code> for ground). Connecting two ports creates or   joins a net.</li> <li>Components \u2013 Python objects with <code>ports</code> and a <code>spice_card(...)</code> method.</li> <li>Circuit \u2013 owns components, nets, and free-form SPICE directives.</li> <li>ResultHandle \u2013 wrapper around simulation artefacts; exposes datasets and metadata.</li> </ul>"},{"location":"concepts/#wiring-rules","title":"Wiring rules","text":"<ul> <li>Connect <code>Port</code> to <code>Net</code>, or <code>Port</code> to <code>Port</code> (implicit net).</li> <li>All ports must be connected before building the netlist.</li> <li>Ground is the reserved node <code>0</code> (use <code>GND</code>).</li> </ul>"},{"location":"concepts/#minimal-rc-example","title":"Minimal RC example","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\n\nc = Circuit(\"rc\")\nV1, R1, C1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\"), Capacitor(\"1\", \"100n\")\nfor comp in (V1, R1, C1):\n    c.add(comp)\n\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\nprint(c.build_netlist())\n</code></pre>"},{"location":"concepts/#directives","title":"Directives","text":"<p>Add raw SPICE lines directly:</p> <pre><code>c.add_directive(\".include ./models/opamp.sub\")\nc.add_directive(\".model SWMOD VSWITCH(Ron=1 Roff=1Meg Vt=2 Vh=0.5)\")\n</code></pre> <p>Directives are emitted above the element cards in the generated netlist.</p>"},{"location":"concepts/#results-metadata","title":"Results &amp; metadata","text":"<p>Simulations return <code>ResultHandle</code> objects. The API is intentionally small:</p> <pre><code>handle.dataset()        # -&gt; xarray.Dataset\nhandle.to_pandas()      # -&gt; pandas.DataFrame\nhandle.to_polars()      # -&gt; polars.DataFrame\nattrs = handle.attrs()  # -&gt; Mapping[str, Any]\n</code></pre> <p>Useful attributes include <code>engine</code>, <code>engine_version</code>, <code>netlist_hash</code>, and <code>analysis_params</code>. Handles also carry paths to the generated netlist / log / RAW artefacts when available.</p>"},{"location":"concepts/#dc-sweeps","title":"DC sweeps","text":"<p>DC datasets normalise the sweep coordinate under <code>sweep</code> and record the original label in <code>dataset.attrs['dc_sweep_label']</code> together with the source name.</p>"},{"location":"concepts/#preview-helpers","title":"Preview helpers","text":"<p><code>Circuit.summary()</code> prints a net connectivity report and <code>Circuit.render_svg()</code> produces a quick Graphviz diagram (see <code>examples/circuit_preview.py</code>).</p> <p>These primitives feed into the higher-level orchestration helpers documented in Engines, Sweeps and Monte Carlo.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Short, copy-paste recipes for common tasks.</p>"},{"location":"cookbook/#basic-measurements-gain-overshoot-settling","title":"Basic measurements (gain, overshoot, settling)","text":"<pre><code>from spicelab.analysis import GainSpec, OvershootSpec, SettlingTimeSpec, measure\n\nspecs = [\n    GainSpec(name=\"gain@1k\", numerator=\"V(out)\", denominator=\"V(in)\", freq=1_000.0),\n    OvershootSpec(name=\"overshoot\", signal=\"V(out)\", target=1.0),\n    SettlingTimeSpec(name=\"settle\", signal=\"V(out)\", target=1.0, tolerance=0.02),\n]\ndf = measure(result_handle, specs)\n</code></pre>"},{"location":"cookbook/#sample-a-trace-at-a-given-time","title":"Sample a trace at a given time","text":"<pre><code>import numpy as np\n\ndef sample_at(ts, name: str, t: float) -&gt; float:\n    t_arr = ts[\"time\"].values\n    y_arr = ts[name].values\n    return float(np.interp(t, t_arr, y_arr))\n</code></pre>"},{"location":"cookbook/#monte-carlo-dataframe","title":"Monte Carlo \u2192 DataFrame","text":"<pre><code>from spicelab.analysis import NormalPct, monte_carlo\nfrom spicelab.core.types import AnalysisSpec\n\nmc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.05)},\n    n=32,\n    analyses=[AnalysisSpec(\"op\", {})],\n    engine=\"ngspice\",\n)\ndf = mc.to_dataframe(metric=None, param_prefix=\"param_\")\n</code></pre>"},{"location":"core-contracts/","title":"Core contracts (deprecated page)","text":"<p>The old milestone-based roadmap has been superseded by the unified orchestrator and measurement APIs. Refer to the up-to-date guides instead:</p> <ul> <li>Concepts</li> <li>Engines</li> <li>Sweeps</li> <li>Monte Carlo</li> <li>Unified I/O</li> </ul>"},{"location":"device-models/","title":"Device models","text":"<p>Many components require SPICE <code>.model</code> cards or <code>.include</code> files. spicelab simply embeds the directives you provide \u2013 it does not ship vendor models.</p>"},{"location":"device-models/#adding-a-model","title":"Adding a model","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Diode\n\nc = Circuit(\"diode_demo\")\nD1 = Diode(\"D1\", model=\"DFAST\")\nc.add(D1)\nc.add_directive(\".model DFAST D(Is=1e-14 Rs=0.5 N=1.1)\")\n</code></pre> <p>The directive is emitted above the rest of the netlist when you call <code>circuit.build_netlist()</code>.</p>"},{"location":"device-models/#including-external-libraries","title":"Including external libraries","text":"<pre><code>c.add_directive('.include \"./models/opamp.sub\"')\n</code></pre> <p>Use <code>.lib</code>, <code>.param</code>, <code>.func</code>, etc. as needed. Directives are preserved verbatim.</p>"},{"location":"device-models/#organising-models","title":"Organising models","text":"<ul> <li>Keep vendor libraries under <code>models/</code> in your project and reference them with   relative paths.</li> <li>Version-control the model source so Monte Carlo and regression tests remain deterministic.</li> <li>Pair directives with <code>netlist_hash</code> metadata when caching simulations \u2013 the hash   should incorporate the model text to avoid stale caches.</li> </ul>"},{"location":"doctor/","title":"Environment Doctor","text":"<p><code>python -m spicelab.doctor</code> inspects your system for common spicelab requirements and reports missing SPICE engines or shared libraries.</p> <pre><code>$ python -m spicelab.doctor\nspicelab environment check\n \u2714 ngspice (/usr/local/bin/ngspice)\n \u2716 ltspice\n    hint: Download LTspice from Analog Devices\n \u26a0 libngspice\n    hint: Install libngspice (e.g. brew install libngspice or apt install libngspice0-dev)\n</code></pre> <p>Checks currently cover:</p> <ul> <li>CLI engines (<code>ngspice</code>, <code>ltspice</code>, <code>xyce</code>) via PATH discovery or the   <code>SPICELAB_*</code> overrides</li> <li>The <code>libngspice</code> shared library used by the co-simulation backend</li> </ul> <p>Results are colour-neutral (plain ASCII) so you can paste them into bug reports. The command returns a non-zero exit code when required engines are missing, making it suitable for CI sanity checks.</p>"},{"location":"doctor/#llm-assisted-qa-optional","title":"LLM-assisted Q&amp;A (optional)","text":"<p>If you install the optional AI extra and configure an OpenAI-compatible API, the doctor can answer questions and propose remediation steps. This is entirely optional and disabled by default.</p> <p>Installation options:</p> <pre><code>pip install spicelab[ai]\n# or\nuv add 'spicelab[ai]'\n</code></pre> <p>Environment variables:</p> <ul> <li><code>OPENAI_API_KEY</code>: your API key (required)</li> <li><code>OPENAI_BASE_URL</code>: optional, for self-hosted or compatible services</li> <li><code>OPENAI_MODEL</code>: default model name (can be overridden with <code>--model</code>)</li> </ul> <p>Usage examples:</p> <pre><code># Text output\nspicelab-doctor --ask \"How do I measure GBW from AC data?\"\n\n# JSON output (machine-readable)\nspicelab-doctor --ask \"Give me a minimal RC netlist\" --format json\n\n# Force a specific model for this request\nspicelab-doctor --ask \"Diagnose ngspice install issues on macOS\" --model gpt-4o-mini\n</code></pre> <p>When <code>--format json</code> is used with <code>--ask</code>, the output includes either the structured fields (<code>intent</code>, <code>summary</code>, <code>steps</code>, <code>commands</code>, <code>circuit_snippet</code>, <code>notes</code>) or a <code>raw</code> field when the model returns non-JSON content.</p>"},{"location":"doctor/#troubleshooting-llm","title":"Troubleshooting LLM","text":"<p>If the LLM integration doesn\u2019t behave as expected, try these tips:</p> <ul> <li>Non-JSON output: Use <code>--format json</code>. If the model returns non-JSON content, the doctor    prints a <code>raw</code> field with the original text. Re-try the question with clearer wording or    shorter prompts.</li> <li>Timeouts or slow responses: Networks and providers can be slow or rate-limited. Re-try the    request, or reduce the prompt size. If you\u2019re using a self-hosted endpoint, check its logs and    capacity. The underlying SDK supports a request timeout; you can open an issue to request a    CLI flag if you need it.</li> <li>Rate limits: Reduce frequency, stagger requests, or use a smaller/lower-cost model.</li> <li>Model errors: Verify <code>OPENAI_MODEL</code> exists for your provider, and that <code>OPENAI_BASE_URL</code> is    correct for self-hosted deployments.</li> </ul>"},{"location":"engines/","title":"Engines","text":"<p>spicelab abstracts SPICE engines behind a small orchestrator. You provide a circuit plus one or more <code>AnalysisSpec</code>s; the library takes care of invoking the chosen engine, collecting artefacts, and normalising the output.</p>"},{"location":"engines/#selecting-an-engine","title":"Selecting an engine","text":"<pre><code>from spicelab.core.types import AnalysisSpec\nfrom spicelab.engines import run_simulation\n\ntran = AnalysisSpec(\"tran\", {\"tstep\": 1e-6, \"tstop\": 1e-3})\nhandle = run_simulation(circuit, [tran], engine=\"ngspice\")\nprint(handle.dataset().data_vars)\n</code></pre> <p><code>engine</code> accepts <code>\"ngspice\"</code>, <code>\"ltspice\"</code>, <code>\"xyce\"</code> (or the explicit <code>*-cli</code> aliases). For lower-level access, call <code>get_simulator(name)</code>.</p> <p>Command-line examples honour the <code>--engine</code> flag and the <code>SPICELAB_ENGINE</code> environment variable.</p>"},{"location":"engines/#binary-discovery","title":"Binary discovery","text":"<p>The CLI adapters search the PATH and fall back to environment variables:</p> Engine Environment variable NGSpice <code>SPICELAB_NGSPICE</code> LTspice <code>SPICELAB_LTSPICE</code> or <code>LTSPICE_EXE</code> Xyce <code>SPICELAB_XYCE</code> <p>Set the variable to the absolute path of the executable when auto-discovery fails. Missing binaries raise <code>EngineBinaryNotFound</code> with install hints.</p>"},{"location":"engines/#ngspice-shared-backend-callbacks","title":"Ngspice shared backend &amp; callbacks","text":"<p><code>NgSpiceSharedSimulator</code> loads the <code>libngspice</code> dynamic library to stream transient data back into Python (<code>on_tran_point</code>) and to drive external sources from user code. Configure it via:</p> <ul> <li>install the shared library (e.g. <code>brew install libngspice</code> or   <code>sudo apt install libngspice0-dev</code>),</li> <li>export <code>SPICELAB_NGSPICE_SHARED</code> to the <code>.so</code>/<code>.dylib</code>/<code>.dll</code> path, and</li> <li>use <code>NgSpiceSharedSimulator()</code> directly or <code>run_simulation(..., engine=\"ngspice-shared\")</code>.</li> </ul> <p>The shared adapter is optimised for per-point control loops. On an M3 Pro laptop the closed-loop example (<code>examples/closed_loop.py</code>) completes ~2\u202f000 transient steps with callbacks in \u224832\u202fms (~16\u202f\u00b5s per step); your numbers will vary with platform, circuit size, and callback complexity. When you need higher throughput\u2014and can tolerate the lack of fine-grained feedback\u2014fall back to the process adapter (<code>engine=\"ngspice\"</code>), which still supports batching, sweeps, and caching but runs headless without callbacks.</p> <p>Tip: keep <code>AnalysisSpec.tstep</code> as large as the control loop allows and perform vectorised work inside the callback to reduce cross-language overhead.</p>"},{"location":"engines/#output-formats","title":"Output formats","text":"Engine Output Notes NGSpice ASCII RAW Control block forces ASCII. LTspice ASCII RAW The adapter passes <code>-b</code> and discovers the generated RAW/log files. Xyce PRN / CSV Parsed into canonical xarray datasets. <p><code>handle.dataset()</code> always returns an <code>xarray.Dataset</code> with canonical coordinates (<code>time</code>, <code>freq</code>, optional <code>step</code>) and signal names (<code>V(node)</code>, <code>I(element)</code>).</p>"},{"location":"engines/#parallelism-caching","title":"Parallelism &amp; caching","text":"<ul> <li>pass <code>workers&gt;1</code> to <code>run_simulation</code> (or <code>run_value_sweep</code> / <code>run_param_grid</code> /   <code>monte_carlo</code>) to enable thread pools.</li> <li>set <code>cache_dir</code> to a persistent location to reuse hashed job results across runs.</li> </ul>"},{"location":"engines/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Binary not found \u2013 install the engine and/or set the environment variable.</li> <li>LTspice still writes binary RAW \u2013 update to the latest LTspice build; on   macOS the CLI always emits ASCII.</li> <li>xarray missing \u2013 install optional dependency (<code>pip install xarray</code>).</li> </ul>"},{"location":"examples-gallery/","title":"Examples Gallery","text":"<p>Curated outputs generated by the spicelab scripts under <code>examples/</code>.</p>"},{"location":"examples-gallery/#step-grid-rc-step-vs-r","title":"STEP Grid (RC step vs R)","text":"<ul> <li>Script: <code>examples/step_sweep_fig.py</code></li> <li>Description: runs a multi-parameter grid and renders the response with Plotly.</li> </ul>"},{"location":"examples-gallery/#monte-carlo-synthetic-data","title":"Monte Carlo (synthetic data)","text":"<ul> <li>Script: <code>examples/mc_demo_plots.py</code></li> <li>Description: generates synthetic samples and showcases the plotting helpers.</li> </ul>"},{"location":"examples-gallery/#reporting-rc-step-response","title":"Reporting (RC step response)","text":"<p>Open the sample HTML report</p> <ul> <li>Script: <code>examples/report_demo.py</code></li> <li>Description: builds a minimal report with tables and an embedded Plotly figure via <code>ReportBuilder</code>.</li> </ul>"},{"location":"examples-usage/","title":"Using the examples","text":"<p>spicelab ships runnable demos under <code>examples/</code>. Execute them from the repository root with <code>uv run --active python examples/&lt;script&gt;.py</code>.</p> <ol> <li>Ensure an engine is available. NGSpice is the default:    <code>bash    brew install ngspice           # macOS    sudo apt install ngspice      # Debian/Ubuntu</code></li> </ol> <p>Xyce users can install the binary from https://xyce.sandia.gov and then export    <code>SPICELAB_XYCE=/path/to/xyce</code> so spicelab can find it.</p> <ol> <li> <p>Install optional plotting dependencies if you want PNG/HTML output:    <code>bash    uv run --active pip install matplotlib pandas    uv run --active pip install \"spicelab[viz]\"   # PyPI install with Plotly extras    # working from a clone? alternatively: uv run --active pip install -e '.[viz]'</code></p> </li> <li> <p>Run any script from the repository root. Examples:    <code>bash    uv run --active python examples/rc_tran.py    uv run --active python examples/sweep_value_unified.py    uv run --active python examples/step_sweep_grid.py    uv run --active python examples/xyce_tran.py --engine xyce    uv run --active python examples/monte_carlo_demo.py --real --engine ngspice --workers 2 --metric-col \"V(vout)\"</code></p> </li> </ol> <p>Most scripts print the engine they used, dataset coordinates/variables, and persist plots or CSVs next to the script.</p> <p>Monte Carlo tip: pass <code>--metric-col</code> to <code>monte_carlo_demo.py</code> when you want to force a specific column from the orchestrator dataframe (for example, <code>V(vout)</code>), ensuring the comparison plots use the metric you expect. HTML exports land in the directory you provide via <code>--out-html</code> (<code>mc_hist.html</code>, <code>mc_param_scatter.html</code>, <code>mc_params_matrix.html</code>).</p> <p>Xyce transient tip: <code>examples/xyce_tran.py</code> falls back gracefully when the engine is missing, so you can run it even before installing Xyce to verify your setup steps.</p>"},{"location":"examples-usage/#notebook-walkthrough","title":"Notebook walkthrough","text":"<p>Prefer an interactive tour? Open <code>examples/notebook_circuit_builder.ipynb</code> in VS Code or JupyterLab after installing the <code>viz</code> extra. It covers:</p> <ul> <li>Building a circuit with the <code>CircuitBuilder</code> DSL.</li> <li>Inspecting connectivity tables and pandas dataframes.</li> <li>Exploring datasets with the interactive widgets, including Monte Carlo sweeps.</li> </ul> <p></p> <p>The Monte Carlo section mirrors the CLI demo but keeps results inside the notebook, ideal for design reviews or quick experiments.</p>"},{"location":"examples/","title":"Examples Overview","text":"<p>The repository ships a small set of runnable scripts under <code>examples/</code>. All of them use the unified orchestrator (<code>run_simulation</code>, <code>run_value_sweep</code>, <code>run_param_grid</code>) and can target any supported engine (NGSpice, LTspice CLI, Xyce).</p> Script Description <code>rc_tran.py</code> RC transient simulation using <code>run_simulation</code>. <code>rc_ac_unified.py</code> AC analysis with engine selection via CLI flag. <code>sweep_value_unified.py</code> Single-component sweep with caching. <code>step_sweep_grid.py</code> Multi-parameter sweep; exports a CSV table. <code>step_sweep_fig.py</code> Same sweep rendered with Plotly. <code>mc_demo_plots.py</code> Generates synthetic Monte Carlo plots for docs. <code>monte_carlo_demo.py</code> Monte Carlo demo with orchestrator fallback and HTML/PNG exports. <code>analog_mux_demo.py</code> Inspects the <code>AnalogMux8</code> component topology. <code>engine_ac_demo.py</code> Minimal AC example using the orchestrator. <code>xyce_tran.py</code> RC transient aimed at Xyce with optional Plotly exports. <p>Run them from the repository root:</p> <pre><code>uv run --active python examples/rc_tran.py\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This quick tour shows how to create a circuit, run an analysis via the unified engine orchestrator, and inspect the results.</p>"},{"location":"getting-started/#1-build-a-circuit","title":"1. Build a circuit","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Capacitor, Resistor, Vdc\nfrom spicelab.core.net import GND\n\nc = Circuit(\"rc_demo\")\nV1 = Vdc(\"VIN\", 5.0)\nR1 = Resistor(\"R\", \"1k\")\nC1 = Capacitor(\"C\", \"100n\")\nfor comp in (V1, R1, C1):\n    c.add(comp)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n</code></pre>"},{"location":"getting-started/#2-run-an-analysis","title":"2. Run an analysis","text":"<pre><code>from spicelab.core.types import AnalysisSpec\nfrom spicelab.engines import run_simulation\n\ntran = AnalysisSpec(\"tran\", {\"tstep\": \"10us\", \"tstop\": \"5ms\"})\nhandle = run_simulation(c, [tran], engine=\"ngspice\")\n</code></pre> <p><code>handle</code> is a <code>ResultHandle</code>. It keeps metadata and a lazy reference to the engine output; call <code>handle.dataset()</code> to get an <code>xarray.Dataset</code> when you need actual data.</p>"},{"location":"getting-started/#3-inspect-the-dataset","title":"3. Inspect the dataset","text":"<pre><code>import pandas as pd\n\nds = handle.dataset()\nprint(ds)\nprint(\"variables:\", list(ds.data_vars))\nprint(\"attrs:\", handle.attrs())\n\n# Convert to pandas if you want tabular data\nprint(ds.to_dataframe().head())\n</code></pre>"},{"location":"getting-started/#4-run-the-bundled-examples","title":"4. Run the bundled examples","text":"<p>From the repository root:</p> <pre><code>uv run --active python examples/rc_tran.py\nuv run --active python examples/sweep_value_unified.py\nuv run --active python examples/step_sweep_grid.py\n</code></pre> <p>Each script prints basic information and (where relevant) saves artefacts next to the script.</p>"},{"location":"installation/","title":"Installation","text":"<p>spicelab ships on PyPI. Use Python 3.10 or newer.</p>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>python -m pip install --upgrade pip\npython -m pip install spicelab\n</code></pre> <p>Extras add optional dependencies:</p> <pre><code>python -m pip install \"spicelab[viz]\"   # Plotly + Kaleido for figure export\npython -m pip install \"spicelab[data]\"  # xarray / polars integrations\n</code></pre> <p>Grab the combined feature set with <code>python -m pip install \"spicelab[viz,data]\"</code>.</p>"},{"location":"installation/#editable-installs-contributing-development","title":"Editable installs (contributing / development)","text":"<pre><code>uv venv\nsource .venv/bin/activate  # Linux/macOS\n# .\\.venv\\Scripts\\activate.ps1  # Windows PowerShell\nuv pip install -e .[viz,data]\n</code></pre> <p>Install extra tooling when hacking on the project:</p> <pre><code>uv pip install -r dev-requirements.txt\n</code></pre>"},{"location":"installation/#spice-engines","title":"SPICE engines","text":"<p>The orchestrator auto-detects engines via environment variables or the system PATH. Install whichever simulators you need:</p> <ul> <li>NGSpice \u2013 <code>brew install ngspice</code> \u00b7 <code>sudo apt install ngspice</code></li> <li>LTspice \u2013 Analog Devices installer (macOS via <code>brew install --cask ltspice</code>)</li> <li>Xyce \u2013 https://xyce.sandia.gov/</li> </ul> <p>Set <code>SPICELAB_NGSPICE</code>, <code>SPICELAB_LTSPICE</code>, or <code>SPICELAB_XYCE</code> to absolute paths if binaries are not on PATH. Missing engines raise informative errors with install hints, and tests tagged <code>@pytest.mark.engine</code> auto-skip when the binary is absent.</p>"},{"location":"installation/#libngspice-shared-library-callbacks","title":"libngspice (shared-library callbacks)","text":"<p>The co-simulation API (<code>NgSpiceSharedSimulator</code>) relies on the dynamic <code>libngspice</code> library so Python callbacks can observe every transient step and drive external sources. Install the shared library alongside the CLI:</p> Platform Command(s) Default library location macOS (Homebrew) <code>brew install libngspice</code> <code>$(brew --prefix libngspice)/lib/libngspice.dylib</code> Debian/Ubuntu <code>sudo apt install libngspice0-dev</code> <code>/usr/lib/x86_64-linux-gnu/libngspice.so</code> Arch Linux <code>sudo pacman -S libngspice</code> <code>/usr/lib/libngspice.so</code> Windows Extract <code>ngspice.dll</code> from the official installer and place it next to your Python project <p>Point spicelab at the library with <code>SPICELAB_NGSPICE_SHARED</code>:</p> <pre><code>export SPICELAB_NGSPICE_SHARED=\"$(brew --prefix libngspice)/lib/libngspice.dylib\"\n# Windows (PowerShell)\n# setx SPICELAB_NGSPICE_SHARED \"C:\\\\path\\\\to\\\\ngspice.dll\"\n</code></pre> <p>Verify that callbacks can load the library before running co-simulation code:</p> <pre><code>python - &lt;&lt;'PY'\nfrom spicelab.spice.ngspice_shared_backend import load_default_backend\nload_default_backend()  # raises EngineSharedLibraryNotFound on failure\nprint(\"libngspice ready\")\nPY\n</code></pre> <p>If the shared library is missing the toolkit transparently falls back to the process-based adapter (<code>engine=\"ngspice\"</code>), which still runs simulations but does not expose live callbacks or external sources.</p>"},{"location":"ltspice-import/","title":"LTspice integration","text":"<p>LTspice schematic and netlist support is being revisited for the new spicelab API. Until that is complete you can:</p> <ol> <li>Export a SPICE netlist from LTspice (<code>View \u2192 SPICE netlist</code>).</li> <li>Load it with <code>spicelab.io.ltspice_parser.from_ltspice_file</code>.</li> <li>Run it through <code>run_simulation(...)</code> with the desired engine.</li> </ol> <pre><code>from spicelab.io.ltspice_parser import from_ltspice_file\nfrom spicelab.core.types import AnalysisSpec\nfrom spicelab.engines import run_simulation\n\ncircuit = from_ltspice_file(\"./my_filter.cir\")\nac = AnalysisSpec(\"ac\", {\"sweep_type\": \"dec\", \"n\": 40, \"fstart\": 10.0, \"fstop\": 1e6})\nhandle = run_simulation(circuit, [ac], engine=\"ltspice\")\nprint(handle.dataset())\n</code></pre> <p>Round-trip schematic editing (<code>ltspice_asc</code>) and property preservation will be documented after the API refresh.</p>"},{"location":"m7-en/","title":"M7 \u2014 Measurements, DSP, and Control Metrics","text":"<p>This milestone delivered a reusable measurement toolkit (similar to SPICE <code>.meas</code>), signal processing helpers, and CLI/pipeline UX for CI-friendly exports.</p> <p>Highlights:</p> <ul> <li>AC: Phase Margin, Gain Bandwidth, Gain Margin with log-frequency interpolation and safe fallbacks.</li> <li>TRAN: Rise Time (10\u201390% with interpolation), THD, ENOB (time-domain sine fit).</li> <li>DSP helpers: windowing, coherent RFFT, amplitude spectrum, PSD with ENBW.</li> <li>CLI <code>spicelab-measure</code>: JSON/CSV output, header-only schema, signal discovery with dtype/axis.</li> <li>Orchestrator pipeline: stable CSV ordering (<code>param_*</code> first) and header sanitization.</li> </ul> <p>See the M7 notebooks under <code>notebooks/</code> for runnable examples.</p>"},{"location":"m7/","title":"M7 \u2014 Measurements & DSP (English)","text":"<p>The M7 page is now available in English. Please see:</p> <ul> <li>M7 \u2014 Measurements &amp; DSP: m7-en.md</li> </ul> <p>This page remains as a pointer to avoid broken links.   - TRAN: overshoot, undershoot, rise/fall time, settling time (\u03b5%), SNR, THD, ENOB (b\u00e1sico)   - NOISE: input-referred, output PSD integrada em banda, NF - Utilidades DSP (<code>spicelab/analysis/signal.py</code>): windowing, FFT coerente, filtros simples - API de alto n\u00edvel: <code>measure(source, specs) -&gt; pl.DataFrame</code> - Integra\u00e7\u00e3o com orchestrator: computar medidas por ponto de sweep/MC</p> <p>Crit\u00e9rios de aceite</p> <ul> <li>Testes cobrindo RC/step e AC/Bode com toler\u00e2ncias razo\u00e1veis</li> <li>Exemplos na documenta\u00e7\u00e3o: Bode + PM/GM e Step + settling/overshoot</li> </ul> <p>Riscos &amp; mitiga\u00e7\u00e3o</p> <ul> <li>Precis\u00e3o de FFT/PSD: documentar janelas/unidades; helpers para normaliza\u00e7\u00e3o</li> </ul> <p>Checklist de implementa\u00e7\u00e3o</p> <ul> <li>[ ] Especificar <code>MeasureSpec</code> adicionais (PM/GM/GBW, THD, ENOB)</li> <li>[ ] Implementar <code>spicelab/analysis/signal.py</code> (janelas, FFT coerente)</li> <li>[ ] Expandir <code>measure()</code> para specs adicionais e integrar com orchestrator</li> <li>[ ] Adicionar testes unit\u00e1rios (happy path + bordas) e exemplos em docs</li> <li>[ ] Atualizar navega\u00e7\u00e3o do MkDocs (se\u00e7\u00e3o M7 / Medidas)</li> </ul>"},{"location":"monte-carlo-example/","title":"Monte Carlo example","text":"<p><code>examples/mc_demo_plots.py</code> generates the static assets used throughout the Circuit Toolkit Monte Carlo documentation. It does not require a simulator: the script creates synthetic samples and feeds them to the plotting helpers.</p> <pre><code>uv run --active python examples/mc_demo_plots.py\n</code></pre> <p>The script writes the following PNG files under <code>docs/assets/examples/</code>:</p> <ul> <li><code>mc_hist.png</code> \u2013 histogram of a synthetic metric.</li> <li><code>mc_metric_kde.png</code> \u2013 kernel density estimate of the same metric.</li> <li><code>mc_R1_vs_metric.png</code> \u2013 scatter plot correlating a parameter with the metric.</li> <li><code>mc_params_matrix.png</code> \u2013 pairwise parameter scatter matrix.</li> </ul> <p>Use these images directly in your docs or replace them with plots generated from real Monte Carlo runs (<code>MonteCarloResult.to_dataframe()</code> + Plotly, Matplotlib, etc.).</p>"},{"location":"monte-carlo-example/#real-orchestrator-demo","title":"Real orchestrator demo","text":"<p>For an end-to-end example that talks to a real simulator (when available), run <code>examples/monte_carlo_demo.py</code>. The script attempts three modes, in order:</p> <ol> <li>Orchestrator-backed Monte Carlo via <code>spicelab.analysis.monte_carlo</code> (supports      workers, caching, synthetic fallbacks).</li> <li>Per-trial <code>run_simulation</code> if the orchestrator helper is unavailable.</li> <li>Synthetic sampling when no engine is present.</li> </ol> <p>Key CLI flags:</p> <ul> <li><code>--real --engine &lt;name&gt;</code>: request an actual engine (for example, <code>ngspice</code>).</li> <li><code>--workers</code> / <code>--cache-dir</code>: forwarded to the orchestrator helper.</li> <li><code>--metric-col &lt;column&gt;</code>: prefer a specific metric column from the dataframe.</li> <li><code>--out-html &lt;dir&gt;</code> / <code>--out-img &lt;dir&gt;</code>: store <code>mc_hist</code>, <code>mc_param_scatter</code>, and     <code>mc_params_matrix</code> in interactive HTML and/or static PNG/SVG format.</li> </ul> <p>Example run:</p> <pre><code>PYTHONPATH=. uv run --active python examples/monte_carlo_demo.py \\\n        --real --engine ngspice --workers 2 --metric-col \"V(vout)\" --out-html out\n</code></pre> <p>When the orchestrator path is used, the sampled parameter dictionaries are augmented with aliases (e.g., <code>R</code>, <code>C</code>) so the plotting helpers always have a numeric axis to render even if only a single component varies.</p>"},{"location":"monte-carlo/","title":"Monte Carlo","text":"<p>spicelab runs Monte Carlo jobs by mapping components to distributions and supplying per-trial analyses. The orchestrator handles caching, multithreading, and xarray/polars exports.</p> <p></p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\nfrom spicelab.analysis import monte_carlo, NormalPct\nfrom spicelab.core.types import AnalysisSpec\n\nc = Circuit(\"rc\")\nV1, R1, C1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\"), Capacitor(\"1\", \"100n\")\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nmc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.05)},\n    n=16,\n    analyses=[AnalysisSpec(\"op\", {})],\n    engine=\"ngspice\",\n    cache_dir=\".spicelab_cache\",\n    seed=123,\n)\n\ndf = mc.to_dataframe(param_prefix=\"param_\")\nprint(df.head())\n\n# Access cached handles / job metadata if needed\nhandles = mc.result_handles()\nif mc.job:\n    print(\"cache dir:\", mc.job.cache_dir)\n</code></pre> <p>Tips: - Use <code>workers</code> for parallel execution and optionally point <code>cache_dir</code> to reuse results between runs. - Provide a metric function to compute scalar KPIs per trial, or set <code>y=[...]</code> and <code>sample_at</code> to extract trace values. - <code>mc.result_handles()</code> and <code>mc.job</code> expose the underlying result handles and cache metadata when you need xarray datasets or cache diagnostics. - When consuming results via the CLI demo (<code>examples/monte_carlo_demo.py</code>), pass <code>--metric-col</code> to enforce which dataframe column becomes the plotted metric (for example, <code>V(vout)</code>). The script exports <code>mc_hist</code>, <code>mc_param_scatter</code>, and <code>mc_params_matrix</code> HTML/PNG files when you supply <code>--out-html</code> / <code>--out-img</code>.</p>"},{"location":"monte-carlo/#progress-bar-callback","title":"Progress bar / callback","text":"<p>Add a lightweight progress bar to stderr:</p> <pre><code>mc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.01)},\n    n=1000,\n    analyses=[AnalysisSpec(\"op\", {})],\n    engine=\"ngspice\",\n    progress=True,   # prints: \"MC: 317/1000 (31%)\"\n)\n</code></pre> <p>Or provide your own callback (<code>done</code>, <code>total</code>):</p> <pre><code>def cb(done: int, total: int) -&gt; None:\n    print(f\"{done}/{total}\", end=\"\\r\")\n\nmc = monte_carlo(\n    c,\n    mapping={R1: NormalPct(0.01)},\n    n=1000,\n    analyses=[AnalysisSpec(\"op\", {})],\n    engine=\"ngspice\",\n    progress=cb,\n)\n</code></pre>"},{"location":"mux-enable-ports/","title":"Analog multiplexer demo","text":"<p>The <code>AnalogMux8</code> component still supports enable ports and <code>.model</code> emission. For the latest example run <code>examples/analog_mux_demo.py</code>:</p> <pre><code>uv run --active python examples/analog_mux_demo.py\n</code></pre> <p>The script prints the SPICE card and, if Graphviz is available, exports an SVG showing the mux topology.</p>"},{"location":"notebooks/","title":"Notebooks","text":"<p>This project includes a set of hands-on notebooks that mirror the main flows in the user guide. You can open them locally in Jupyter or VS Code.</p> <ul> <li>01 \u2013 Getting Started: basic RC example and transient analysis.</li> <li>02 \u2013 Engines &amp; Setup: environment checks and choosing an engine.</li> <li>03 \u2013 Sweeps &amp; Grids: value sweep and multi-parameter grids.</li> <li>04 \u2013 Monte Carlo: distributions, runs, results, and plots.</li> <li>05 \u2013 Visualization &amp; Widgets: Plotly timeseries and dataset widgets.</li> <li>06 \u2013 DSL Circuit Builder: interactive circuit construction.</li> </ul> <p>Notebook files (open from repo root):</p> <ul> <li><code>notebooks/01-getting-started.ipynb</code></li> <li><code>notebooks/02-engines-and-setup.ipynb</code></li> <li><code>notebooks/03-sweeps-and-grids.ipynb</code></li> <li><code>notebooks/04-monte-carlo.ipynb</code></li> <li><code>notebooks/05-visualization-and-widgets.ipynb</code></li> <li><code>notebooks/06-dsl-circuit-builder.ipynb</code></li> </ul> <p>Tip: In VS Code, right-click a notebook and choose \u201cOpen in Notebook Editor\u201d.</p>"},{"location":"opamp-stability/","title":"Op-amp stability (placeholder)","text":"<p>A refreshed stability guide will arrive together with the measurement helper examples. For now, combine the measurement specs from the Cookbook with AC sweeps produced by <code>run_simulation</code> to compute phase/gain margins.</p>"},{"location":"plots/","title":"Plotting","text":"<p>spicelab ships interactive Plotly helpers for common visualization tasks. Each helper returns a <code>VizFigure</code>, which wraps the underlying Plotly figure and exposes <code>show()</code>, <code>to_html()</code>, and <code>to_image()</code> convenience methods.</p> <p>Install the optional <code>viz</code> extra to pull in Plotly and Kaleido (for static image export):</p> <pre><code>pip install spicelab[viz]\n</code></pre>"},{"location":"plots/#time-domain-traces","title":"Time-domain traces","text":"<pre><code>from spicelab.viz import plot_traces\n\nds = handle.dataset()\nfig = plot_traces(ds, ys=[\"V(R)\", \"I(R)\"] , title=\"RC response\")\nfig.to_html(\"rc_response.html\")  # standalone HTML with embedded Plotly figure\n</code></pre>"},{"location":"plots/#bode-plots","title":"Bode plots","text":"<pre><code>from spicelab.viz import plot_bode\n\n# 'y' must reference a complex trace (AC/Small-signal analysis)\nac_ds = ac_handle.dataset()\nbode_fig = plot_bode(ac_ds, y=\"V(vout)\")\nbode_fig.show()  # open an interactive browser window\n</code></pre>"},{"location":"plots/#step-responses","title":"Step responses","text":"<pre><code>from spicelab.viz import plot_step_response\n\ntran_ds = tran_handle.dataset()  # time-domain dataset\nstep_fig = plot_step_response(\n    tran_ds,\n    y=\"V(vout)\",\n    settle_tolerance=0.02,\n    title=\"RC step response\",\n)\nstep_fig.to_html(\"rc_step_response.html\")\n</code></pre> <p><code>plot_step_response</code> annotates rise time, overshoot and settling bands automatically when enough data is available. Pass <code>x=\"time\"</code> to force a specific coordinate or override <code>steady_state</code>/<code>initial_value</code> when the default heuristics are not sufficient.</p>"},{"location":"plots/#nyquist-plots","title":"Nyquist plots","text":"<pre><code>from spicelab.viz import plot_nyquist\n\nloop_ds = ac_loop_handle.dataset()  # AC dataset with loop gain trace\nnyquist_fig = plot_nyquist(loop_ds, y=\"loop_gain\", title=\"Loop Nyquist\")\nnyquist_fig.show()\n</code></pre> <p>The Nyquist helper draws the complex trajectory of the selected trace and highlights the last segment direction to simplify stability inspections. Provide <code>xlabel</code>/<code>ylabel</code> to rename axes or disable <code>show_arrow</code> when exporting static reports.</p>"},{"location":"plots/#parameter-sweeps","title":"Parameter sweeps","text":"<pre><code>from spicelab.viz import plot_sweep_df\n\nfig = plot_sweep_df(df, x=\"time\", y=\"v(vout)\", hue=\"R\", title=\"Parameter sweep\")\nfig.to_image(\"sweep.png\")  # requires kaleido; falls back to HTML otherwise\n</code></pre> <p>Explore <code>spicelab.viz</code> for lower-level building blocks (<code>time_series_view</code>, <code>bode_view</code>, <code>monte_carlo_histogram</code>, <code>monte_carlo_param_scatter</code>, etc.) when you want to assemble custom dashboards or compose multiple views manually.</p>"},{"location":"preview/","title":"Circuit Preview (Summary and Graphviz)","text":"<p>Use the spicelab preview helpers to validate connectivity and generate a quick Graphviz-based diagram of nets and components (no schematic rendering).</p>"},{"location":"preview/#connectivity-summary","title":"Connectivity summary","text":"<pre><code>print(c.summary())\n</code></pre> <p>Outputs a compact mapping of <code>ref.port -&gt; net</code>, highlights nets with degree 1 and unconnected ports.</p>"},{"location":"preview/#graphviz-rendering","title":"Graphviz rendering","text":"<pre><code>dot = c.to_dot()\n# render_svg() will call out to the `dot` binary if available; otherwise you can run dot manually:\nok = c.render_svg(\"circuit_preview.svg\")  # requires 'dot' in PATH\n</code></pre> <p>If Graphviz isn't installed, you still get a <code>.dot</code> file:</p> <pre><code>dot -Tsvg circuit_preview.dot -o preview.svg\n</code></pre> <p>Example (RC low-pass):</p> <p></p>"},{"location":"preview/#netlist-helpers","title":"Netlist helpers","text":"<pre><code>print(c.netlist_string())\n# or\nc.print_netlist()\n</code></pre>"},{"location":"preview/#monte-carlo-quick-export-plots","title":"Monte Carlo \u2014 quick export &amp; plots","text":"<pre><code># run a Monte Carlo varying components (example only)\nfrom spicelab.analysis.montecarlo import monte_carlo, NormalPct\nfrom spicelab.core.types import AnalysisSpec\n\n# mapping would be Component -&gt; Dist (here pseudo-code)\n# mc = monte_carlo(\n#     circuit,\n#     mapping,\n#     n=100,\n#     analyses=[AnalysisSpec('tran', {'tstep': '1e-6', 'tstop': '1e-3'})],\n#     engine='ngspice',\n#     cache_dir='.spicelab_cache',\n# )\n\n# export sampled parameters and the manifest\n# mc.save_samples_csv('mc_samples.csv')\n# mc.save_manifest_csv('mc_manifest.csv')\n\n# compute a metric per run (example: final Vout) and plot\n# metrics = [my_metric(r) for r in mc.runs]\n# from spicelab.viz import plot_mc_metric_hist, plot_param_vs_metric\n# fig_hist = plot_mc_metric_hist(metrics, title='Gain distribution')\n# fig_scatter = plot_param_vs_metric(mc.samples, metrics, param='R1')\n</code></pre> <p>Example outputs (generated by <code>examples/mc_demo_plots.py</code>):</p> <p></p> <p></p> <p></p>"},{"location":"reporting/","title":"Reporting Helpers","text":"<p>spicelab ships with a minimal reporting layer so simulation scripts can produce shareable artefacts (HTML or Markdown) without pulling in a full templating engine. The core entry point is <code>spicelab.reporting.ReportBuilder</code>.</p> <pre><code>import numpy as np\nfrom pathlib import Path\nfrom spicelab.io.raw_reader import Trace, TraceSet\nfrom spicelab.reporting import ReportBuilder\nfrom spicelab.viz.plotly import time_series_view\n\n# Assume ``handle`` is a ResultHandle from run_simulation()\nds = handle.dataset()\ntime = ds.coords[\"time\"].values\nvout = ds[\"V(out)\"].values\ntraces = TraceSet([\n    Trace(\"time\", \"s\", np.asarray(time)),\n    Trace(\"V(out)\", \"V\", np.asarray(vout)),\n])\nfigure = time_series_view(traces, ys=[\"V(out)\"])\n\nreport = ReportBuilder(\"RC transient\", subtitle=\"Monte Carlo sample #12\")\nsummary = report.add_section(\"Summary\")\nsummary.add_markdown(\"Circuit converged in 1.2 ms with no warnings.\")\nsummary.add_table([\n    {\"element\": \"R1\", \"value\": \"1 kOhm\"},\n    {\"element\": \"C1\", \"value\": \"100 nF\"},\n], caption=\"Component values\")\nsummary.add_figure(figure, caption=\"Output voltage vs. time\")\n\noutputs = report.write(Path(\"reports\"))\nprint(\"HTML report at\", outputs[\"html\"])\n</code></pre> <p><code>ReportBuilder</code> manages sections, tables, inline markdown, and embedded figures. Figure blocks accept <code>VizFigure</code> instances (from Plotly helpers) or raw HTML strings; assets are written under <code>reports/figures/</code> and linked from the main report. Tables accept <code>polars.DataFrame</code>, pandas data frames, or simple <code>list[dict]</code> structures.</p>"},{"location":"reporting/#dataset-summary","title":"Dataset summary","text":"<p>To turn an <code>xarray.Dataset</code> into a compact table, use <code>spicelab.reporting.report.dataset_summary</code>:</p> <pre><code>from spicelab.reporting import ReportBuilder\nfrom spicelab.reporting.report import dataset_summary\n\nreport = ReportBuilder(\"AC sweep\")\nsection = report.add_section(\"Dataset\")\nsection.add_table(dataset_summary(handle.dataset()), caption=\"Variables &amp; dimensions\")\n</code></pre> <p>The helper returns <code>(headers, rows)</code> ready to feed into <code>ReportSection.add_table</code>.</p>"},{"location":"reporting/#output-formats","title":"Output formats","text":"<p><code>ReportBuilder.write()</code> accepts any combination of <code>html</code> and <code>md</code> formats. HTML output includes a lightweight stylesheet for readability, while the Markdown variant is primed for changelog attachments or quick email summaries.</p> <p>Set <code>include_figures=False</code> if you only need textual output.</p>"},{"location":"sweeps-step/","title":"Sweeps","text":"<p>The orchestrator API lets you sweep component values across any supported engine (NGSpice, LTspice CLI, Xyce) while reusing cache entries and working with typed result handles. Two helpers cover the common cases:</p> <ul> <li><code>run_value_sweep</code> \u2014 sweep a single component over a list of values.</li> <li><code>run_param_grid</code> \u2014 evaluate the Cartesian product of multiple components/values.</li> </ul> <p>Both helpers return lightweight objects containing <code>ResultHandle</code> instances. You can inspect datasets on demand and reuse cached results transparently.</p>"},{"location":"sweeps-step/#single-component-value-sweep","title":"Single-component value sweep","text":"<pre><code>from spicelab.analysis.sweep_grid import run_value_sweep\nfrom spicelab.core.types import AnalysisSpec\n\nsweep = run_value_sweep(\n    circuit=c,\n    component=R1,\n    values=[\"1k\", \"2k\", \"5k\"],\n    analyses=[AnalysisSpec(\"tran\", {\"tstep\": \"50us\", \"tstop\": \"5ms\"})],\n    engine=\"ngspice\",\n    cache_dir=\".spicelab_cache\",\n)\n\nfor sweep_run in sweep.runs:\n    ds = sweep_run.handle.dataset()\n    print(sweep_run.value, float(ds[\"V(R1)\"][-1]))\n</code></pre>"},{"location":"sweeps-step/#multi-parameter-grid","title":"Multi-parameter grid","text":"<pre><code>from spicelab.analysis.sweep_grid import run_param_grid\n\nvariables = [\n    (V1, [1.0, 5.0]),\n    (R1, [\"1k\", \"2k\"]),\n    (C1, [\"100n\", \"220n\"]),\n]\n\nresult = run_param_grid(\n    circuit=c,\n    variables=variables,\n    analyses=[AnalysisSpec(\"op\", {})],\n    engine=\"ngspice\",\n    cache_dir=\".spicelab_cache\",\n    workers=4,\n)\n\nfor run in result.runs:\n    print(run.combo, run.from_cache)\n</code></pre> <p>Each <code>run.combo</code> is a dictionary mapping component references to the value used for that simulation. Call <code>run.handle.dataset()</code> when you need the full <code>xarray.Dataset</code> and <code>run.handle.attrs()</code> for metadata (engine, netlist hash, paths to artifacts, etc.).</p>"},{"location":"sweeps-step/#native-step","title":"Native <code>.step</code>","text":"<p>If you already have a netlist that contains a <code>.step</code> directive the orchestrator helpers are not required. Run the engine directly and parse the multi-plot RAW file with the unified readers module.</p>"},{"location":"tran-measurements/","title":"Transient measurements","text":"<p>Time-domain measurements available in <code>spicelab.analysis.measure</code> and tips to get robust results.</p>"},{"location":"tran-measurements/#available-specs","title":"Available specs","text":"<ul> <li>RiseTimeSpec \u2014 10\u201390% rise time between threshold crossings (configurable via <code>low_pct</code>/<code>high_pct</code>).</li> <li>THDSpec \u2014 Total Harmonic Distortion (%) from a steady-state sine; detects fundamental or accept <code>f0</code>.</li> <li>ENOBSpec \u2014 Effective number of bits from time-domain sine fit and SINAD: ENOB = (SINAD_dB \u2212 1.76)/6.02.</li> </ul>"},{"location":"tran-measurements/#usage","title":"Usage","text":"<pre><code>from spicelab.analysis.measure import measure, RiseTimeSpec, THDSpec, ENOBSpec\nrows = measure(ds, [\n  RiseTimeSpec(name=\"tr\", signal=\"V(out)\"),\n  THDSpec(name=\"thd\", signal=\"V(out)\", harmonics=5, f0=1e3),\n  ENOBSpec(name=\"enob\", signal=\"V(out)\", harmonics=5, f0=1e3),\n], return_as=\"python\")\n</code></pre>"},{"location":"tran-measurements/#tips-for-accuracy","title":"Tips for accuracy","text":"<ul> <li>Windowing and coherence: Internally, FFT helpers use Hann windows and a coherent RFFT when needed. For sine-based THD/ENOB, provide <code>f0</code> when possible and run for an integer number of cycles to reduce leakage.</li> <li>Sampling: Use sufficiently small <code>tstep</code> and simulate long enough to include multiple cycles after any initial transient. Discard startup cycles if ringing is present.</li> <li>ENOB method: The implementation fits a sine in time-domain (least squares) to avoid FFT scaling pitfalls, improving robustness in the presence of modest jitter and DC offsets.</li> <li>Edge cases: Rise time uses linear interpolation for threshold crossings; ensure the waveform crosses the defined thresholds once.</li> </ul>"},{"location":"tran-measurements/#engine-example","title":"Engine example","text":"<p>See <code>examples/ngspice_tran_metrics.py</code> for a minimal RC rise-time and a sine-based THD/ENOB using ngspice.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<ul> <li>Engine not found \u2013 install the simulator and ensure it is on PATH, or set   <code>SPICELAB_NGSPICE</code>, <code>SPICELAB_LTSPICE</code>, <code>SPICELAB_XYCE</code> to the absolute binary path.</li> <li>Binary RAW detected \u2013 <code>load_dataset</code> defaults to ASCII. Re-run the engine via   the orchestrator (which requests ASCII) or opt in with <code>allow_binary=True</code>.</li> <li>Unconnected port \u2013 every component port must be tied to a net before calling   <code>Circuit.build_netlist()</code>.</li> <li>Trace missing from dataset \u2013 canonical names are <code>V(node)</code> and <code>I(element)</code>;   check <code>handle.dataset().data_vars</code> for the normalised names.</li> <li>Phase / magnitude confusion \u2013 feed AC datasets into the measurement helpers   or Plotly utilities (<code>plot_bode</code>). Use <code>complex_components=True</code> when loading   RAW files if you need real/imaginary channels.</li> <li>Cache not reused \u2013 ensure <code>cache_dir</code> is stable and that the circuit hash   incorporates any external <code>.model</code> or <code>.include</code> files.</li> </ul>"},{"location":"unified-io/","title":"Unified I/O","text":"<p>spicelab provides unified readers that normalise waveform outputs from NGSpice, LTspice, and Xyce into a single <code>xarray.Dataset</code> structure with consistent coordinates, canonical signal names, and provenance metadata.</p>"},{"location":"unified-io/#goals","title":"Goals","text":"<ul> <li>Single entrypoint to parse RAW / PRN / CSV waveforms.</li> <li>Canonical coordinates: <code>time</code> or <code>freq</code>, plus optional <code>step</code> dimension for multi-plot (.step) outputs.</li> <li>Canonical signal naming: <code>V(node)</code>, <code>I(element)</code>.</li> <li>Metadata for reproducibility: engine, engine_version (when available), netlist hash, analysis arguments, log warnings/errors.</li> </ul>"},{"location":"unified-io/#public-api","title":"Public API","text":"<pre><code>from spicelab.io import load_dataset, read_waveform\n\n# High-level (recommended) with enrichment &amp; normalization\nds = load_dataset(\n    \"run.raw\",\n    engine=\"ngspice\",\n    log=\"run.log\",\n    netlist_hash=\"abc123\",\n    analysis_args={\"tstop\": 1e-3},\n    allow_binary=True,  # binary RAW now supported\n)\n\n# Lower-level dispatch (auto by extension, minimal enrichment)\nds2 = read_waveform(\"run.prn\")\n</code></pre>"},{"location":"unified-io/#load_dataset","title":"<code>load_dataset(...)</code>","text":"<p>Parameters: - <code>path</code>: waveform file (.raw / .prn / .csv) - <code>engine</code>: optional explicit engine name (<code>ngspice|ltspice|xyce</code>) - <code>log</code>: ngspice log file to harvest version, warnings, errors - <code>netlist_hash</code>: stable hash of the netlist/circuit (see core hashing API) - <code>analysis_args</code>: dict of parameters (e.g. tstep, tstop, npoints) - <code>allow_binary</code>: if False and RAW detected as binary, raises (set True to parse)</p> <p>Returns: <code>xarray.Dataset</code> with: - Coordinates: <code>time</code> or <code>freq</code>, <code>step</code> (if multi-plot/.step) - Data variables: signal traces (float arrays; AC magnitude by default, optional real/imag/phase expansion) - Rich <code>attrs</code> metadata (see table below)</p>"},{"location":"unified-io/#complex-ac-components","title":"Complex AC Components","text":"<p>By default AC analyses provide magnitude-only traces (original RAW magnitude). Pass <code>complex_components</code> to expand complex parts into additional variables:</p> <pre><code># All three canonical components\nds = load_dataset(\"ac_run.raw\", engine=\"ngspice\", complex_components=True, allow_binary=True)\nlist(ds.data_vars)\n# ['V(out)', 'V(out)_real', 'V(out)_imag', 'V(out)_phase_deg', ...]\n\n# Only real + imag (omit phase)\nds = load_dataset(\"ac_run.raw\", complex_components=(\"real\", \"imag\"))\n\n# Any subset (case-insensitive): {'real','imag','phase'}\n</code></pre> <p>Rules: - Magnitude (original value) is always preserved under the base signal name. - Expanded channels are suffixed with <code>_real</code>, <code>_imag</code>, <code>_phase_deg</code>. - Phase is in degrees; convert to radians as needed: <code>np.deg2rad(ds['V(out)_phase_deg'])</code>. - Applied components recorded in <code>ds.attrs['complex_components']</code>.</p>"},{"location":"unified-io/#device-current-normalization-extensions","title":"Device Current Normalization Extensions","text":"<p>Additional raw device quantity patterns are canonicalized:</p> Raw Pattern Canonical Output <code>@R1[i]</code> <code>I(R1)</code> <code>@M1[id]</code> (drain current) <code>Id(M1)</code> <code>Ix(U1:...)</code> <code>I(U1:...)</code> (existing) <p>This complements existing voltage/current normalization (<code>V(node)</code>, <code>I(element)</code>). Drain currents keep the <code>Id(...)</code> form to distinguish from total element current when relevant.</p>"},{"location":"unified-io/#read_waveformpath","title":"<code>read_waveform(path)</code>","text":"<p>Thin dispatch by extension, no metadata enrichment (use when you only need quick parsing).</p>"},{"location":"unified-io/#multi-step-step-handling","title":"Multi-step (.step) Handling","text":"<p>ASCII RAW files with multiple plot blocks are merged along a <code>step</code> dimension:</p> <pre><code>multi = load_dataset(\"sweep.raw\", engine=\"ngspice\")\nassert \"step\" in multi.dims\n</code></pre> <p>Each original plot contributes one slice along <code>step</code>; the independent variable (<code>time</code> / <code>freq</code>) is shared.</p>"},{"location":"unified-io/#normalization-rules","title":"Normalization Rules","text":"Input Pattern Canonical <code>v(out)</code>, <code>V(out)</code> <code>V(out)</code> <code>i(R1)</code>, <code>I(R1)</code> <code>I(R1)</code> <code>time</code>, <code>t</code>, <code>tempo</code> coord <code>time</code> <code>freq</code>, <code>f</code>, <code>frequency</code> coord <code>freq</code> <p>If a coordinate alias appears only as a data variable it is lifted into a coordinate.</p>"},{"location":"unified-io/#provenance-metadata","title":"Provenance Metadata","text":"<p>Attach run context so artifacts are reproducible:</p> <pre><code>net_hash = \"abc123ef45\"  # produced by circuit_hash(circuit)\ntran = load_dataset(\"rc_tran.raw\", engine=\"ngspice\", netlist_hash=net_hash, analysis_args={\"tstop\": 2e-3})\nprint(tran.attrs[\"netlist_hash\"], tran.attrs[\"analysis_args\"])  # =&gt; abc123ef45 {\"tstop\": 0.002}\n</code></pre>"},{"location":"unified-io/#helpers-conversions","title":"Helpers &amp; Conversions","text":"<p>Waveforms can be converted, serialized and introspected via helper functions:</p> <pre><code>from spicelab.io import (\n    to_polars, to_pandas, dataset_to_long_polars,\n    save_dataset, load_saved_dataset, list_signals\n)\n\npl_df = to_polars(ds)                  # Wide form (one column per signal)\npd_df = to_pandas(ds)                  # Pandas wide form\nlong_df = dataset_to_long_polars(ds)   # Melted: coord columns + (signal,value)\n\nsave_dataset(ds, \"waveform.nc\")        # NetCDF\nsave_dataset(ds, \"waveform.parquet\", format=\"parquet\")\nreloaded = load_saved_dataset(\"waveform.nc\")\n\nsig_classes = list_signals(ds)\nprint(sig_classes[\"voltage\"], sig_classes[\"current\"])  # classification\n</code></pre>"},{"location":"unified-io/#metadata-attributes","title":"Metadata Attributes","text":"<p>The loader enriches datasets with provenance &amp; structural metadata when available:</p> Key Description <code>engine</code> Detected or provided engine (<code>ngspice</code>, <code>ltspice</code>, <code>xyce</code>) <code>engine_version</code> Heuristic or log-derived version string <code>analysis</code> Raw analysis name (e.g. <code>tran</code>, <code>ac</code>) inferred from plot header <code>analysis_kind</code> Canonical analysis alias (mirrors <code>analysis</code> today) <code>raw_path</code> Source path of waveform file <code>stepped</code> Boolean: multi-plot (.step) merged dataset <code>steps</code> Total number of steps (if stepped) <code>step_index</code> Index of this slice inside a multi-step set (per-plot before merge) <code>netlist_hash</code> Stable circuit/netlist hash provided by caller <code>analysis_args</code> Dict of simulation parameters (user supplied) <code>log_warnings</code> / <code>log_errors</code> Parsed ngspice log diagnostics <code>provenance</code> JSON blob with load timestamp (and future lineage) <code>n_points</code> Number of sample points in primary dimension <code>current_signals</code> List of canonical current signal names (<code>I(...)</code>) <code>subckt_currents</code> Subcircuit current subset (normalized <code>Ix(...) -&gt; I(...)</code>) <code>time_offset</code> Offset extracted from LTspice binary header (if present) <code>command</code> LTspice original run command (binary RAW header) <code>backannotation</code> Backannotation info from LTspice header (if present) <code>title</code> / <code>plot_title</code> Original plot title text (when provided) <p>Missing keys simply mean the information was not derivable for that file.</p>"},{"location":"unified-io/#example-end-to-end-doctest-style","title":"Example End-to-End (doctest style)","text":"<pre><code>&gt;&gt;&gt; from spicelab.io import load_dataset, to_pandas\n&gt;&gt;&gt; ds = load_dataset(\"tests/fixtures/rc_tran_ng.raw\", engine=\"ngspice\")\n&gt;&gt;&gt; \"time\" in ds.coords\nTrue\n&gt;&gt;&gt; sorted(v for v in ds.data_vars)  # signals\n['I(R1)', 'V(out)']\n&gt;&gt;&gt; df = to_pandas(ds)\n&gt;&gt;&gt; list(df.columns)[:3]\n['time', 'I(R1)', 'V(out)']  # order may vary slightly\n</code></pre> <p>(Upcoming: coords will become index columns automatically.)</p>"},{"location":"unified-io/#binary-raw-support","title":"Binary RAW Support","text":"<p>Both ASCII and binary LTspice/ngspice RAW formats are supported:</p> <ul> <li>UTF-8 or UTF-16 (\"wide\") headers auto-detected (LTspice sometimes emits UTF\u201116 with NULL bytes).</li> <li>Binary payload layout is heuristically detected (point-major vs variable-major) and scalar size (float32 vs float64) inferred from file length.</li> <li>AC analyses with complex traces retain magnitude data by default; optional real/imag/phase channels via <code>complex_components</code>.</li> <li>Subcircuit currents <code>Ix(U1:...)</code> are normalized to canonical <code>I(U1:...)</code>.</li> </ul> <p>Set <code>allow_binary=True</code> in <code>load_dataset</code> for clarity (default is False for explicit opt-in; lower-level <code>read_waveform</code> defaults to True).</p>"},{"location":"unified-io/#parity-tests","title":"Parity Tests","text":"<p>Fixtures in <code>tests/fixtures</code> exercise transient &amp; AC outputs (ASCII + binary) synthesized for ngspice, LTspice and Xyce. A relaxed tolerance (2\u201315%) validates expected numeric proximity while allowing formatting differences.</p>"},{"location":"unified-io/#roadmap-next-enhancements","title":"Roadmap (Next Enhancements)","text":"<ul> <li>Refine engine version extraction (LTspice, Xyce) with stricter regex and caching.</li> <li>Promote coords as index / multi-index in <code>to_pandas</code> / <code>to_polars</code>.</li> <li>Noise / distortion / spectral density ingestion.</li> <li>Additional export formats &amp; compression knobs.</li> <li>Optional radians phase output (<code>_phase_rad</code>) toggle.</li> </ul>"},{"location":"unified-io/#troubleshooting","title":"Troubleshooting","text":"Symptom Cause Fix <code>NotImplementedError: Binary RAW detected</code> <code>allow_binary=False</code> guard triggered Re-run with <code>allow_binary=True</code> or call <code>read_waveform</code> directly Missing <code>time</code> coord Alias only present as variable (<code>t</code>, etc.) Use <code>load_dataset</code> (auto promotes) Inconsistent variable names across engines Raw headers differ Use canonical names after normalization (<code>V(node)</code>, <code>I(element)</code>) Garbled header characters UTF\u201116 LTspice header Auto-detected; if persists report with sample file Unexpected small/half data length Scalar size/layout heuristic mismatch File may be truncated; open an issue with the RAW file <p>For deeper provenance link the dataset hash to your run cache using <code>netlist_hash</code> plus analysis args.</p>"},{"location":"unified-io/#api-reference","title":"API Reference","text":"<p>See the auto-generated API docs for details:</p> <ul> <li>IO Reference</li> </ul>"},{"location":"assets/examples/rc_report_demo/","title":"RC Step Response","text":"<p>Synthetic example report</p>"},{"location":"assets/examples/rc_report_demo/#summary","title":"Summary","text":"<p>This report showcases the :code:<code>ReportBuilder</code> helper with a synthetic RC charging curve rendered via Plotly.</p> parameter value Resistance 1 k\u03a9 Capacitance 100 nF \u03c4 0.1 ms Component values used to generate the trace col1 col2 col3 kind name details ['dimension', 'time', '400'] ['variable', 'V(out)', '400'] Dataset structure"},{"location":"assets/examples/rc_report_demo/#waveform","title":"Waveform","text":"<p>Output voltage versus time</p>"},{"location":"reference/analysis/","title":"Analysis API","text":"<p>Placeholder for analysis API docs.</p> <p>Public analysis helpers for the unified API.</p>"},{"location":"reference/analysis/#spicelab.analysis.AnalysisResult","title":"<code>AnalysisResult</code>  <code>dataclass</code>","text":"<p>Lightweight container used by Monte Carlo helpers for legacy traces.</p> Source code in <code>spicelab/analysis/result.py</code> <pre><code>@dataclass(frozen=True)\nclass AnalysisResult:\n    \"\"\"Lightweight container used by Monte Carlo helpers for legacy traces.\"\"\"\n\n    run: RunResult\n    traces: TraceSet\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.ENOBSpec","title":"<code>ENOBSpec</code>  <code>dataclass</code>","text":"<p>Effective number of bits estimated from SINAD of a sine wave.</p> <p>ENOB = (SINAD_dB - 1.76) / 6.02</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass ENOBSpec:\n    \"\"\"Effective number of bits estimated from SINAD of a sine wave.\n\n    ENOB = (SINAD_dB - 1.76) / 6.02\n    \"\"\"\n\n    name: str\n    signal: str\n    harmonics: int = 5\n    f0: float | None = None\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.GainBandwidthSpec","title":"<code>GainBandwidthSpec</code>  <code>dataclass</code>","text":"<p>Unity-gain frequency for H = numerator/denominator (GBW for open-loop A).</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass GainBandwidthSpec:\n    \"\"\"Unity-gain frequency for H = numerator/denominator (GBW for open-loop A).\"\"\"\n\n    name: str\n    numerator: str\n    denominator: str\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.GainMarginSpec","title":"<code>GainMarginSpec</code>  <code>dataclass</code>","text":"<p>Gain margin at phase = -180\u00b0 (mod 360) for H = numerator/denominator.</p> <p>Returns the classical GM in dB: GM_dB = -20*log10(|H|) evaluated at the phase-crossing (closest sample to -180\u00b0 modulo 360). If no sample is within <code>tolerance_deg</code> of -180\u00b0, returns +inf (no crossing within range).</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass GainMarginSpec:\n    \"\"\"Gain margin at phase = -180\u00b0 (mod 360) for H = numerator/denominator.\n\n    Returns the classical GM in dB: GM_dB = -20*log10(|H|) evaluated at the\n    phase-crossing (closest sample to -180\u00b0 modulo 360). If no sample is within\n    `tolerance_deg` of -180\u00b0, returns +inf (no crossing within range).\n    \"\"\"\n\n    name: str\n    numerator: str\n    denominator: str\n    tolerance_deg: float = 15.0\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.GainSpec","title":"<code>GainSpec</code>  <code>dataclass</code>","text":"<p>Measure the small-signal gain at a given frequency.</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass GainSpec:\n    \"\"\"Measure the small-signal gain at a given frequency.\"\"\"\n\n    name: str\n    numerator: str\n    freq: float\n    denominator: str | None = None\n    kind: Literal[\"mag\", \"db\"] = \"db\"\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult","title":"<code>MonteCarloResult</code>  <code>dataclass</code>","text":"Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>@dataclass(frozen=True)\nclass MonteCarloResult:\n    samples: list[dict[str, float]]\n    runs: list[AnalysisResult]\n    # optional metadata about the varied parameters: list of (label, nominal, dist_repr)\n    mapping_manifest: list[tuple[str, float, str]] | None = None\n    handles: list[ResultHandle] | None = None\n    job: JobResult | None = None\n\n    def result_handles(self) -&gt; list[ResultHandle]:\n        \"\"\"Return the list of ResultHandle objects backing each run (if available).\"\"\"\n\n        return list(self.handles or [])\n\n    def to_dataframe(\n        self,\n        metric: (\n            Callable[[AnalysisResult], float | dict[str, Any]]\n            | TMapping[str, Callable[[AnalysisResult], Any]]\n            | None\n        ) = None,\n        *,\n        trial_name: str = \"trial\",\n        param_prefix: str = \"\",\n        y: Sequence[str] | None = None,\n        sample_at: float | None = None,\n    ) -&gt; Any:\n        \"\"\"\n        Returns a per-trial DataFrame with columns:\n          - trial (index within this Monte Carlo run)\n          - one column per sampled parameter (from `samples`), optionally prefixed\n          - optional metric columns computed from each AnalysisResult\n          - optional raw trace columns (final value or sampled at `sample_at` seconds)\n\n        metric:\n          - callable \u2192 result stored in column 'metric' (float or scalar)\n          - mapping name-&gt;callable \u2192 adds one column per metric name\n        y: list of trace names to extract values for each run. If `sample_at` is given,\n           the value is linearly interpolated at t=sample_at using the run's time axis;\n           otherwise, the last value in the trace is used.\n        \"\"\"\n        try:\n            pd: Any = importlib.import_module(\"pandas\")\n        except Exception:  # pragma: no cover\n            pd = None\n\n        rows: list[dict[str, Any]] = []\n        for i, (s, run) in enumerate(zip(self.samples, self.runs, strict=False)):\n            # copy sampled params; optionally add prefix\n            if param_prefix:\n                row = {f\"{param_prefix}{k}\": v for k, v in s.items()}\n            else:\n                row = dict(s)\n            row[trial_name] = i\n            if metric is not None:\n                if hasattr(metric, \"items\"):\n                    for name, fn in cast(\n                        TMapping[str, Callable[[AnalysisResult], Any]], metric\n                    ).items():\n                        row[name] = fn(run)\n                else:\n                    m = cast(Callable[[AnalysisResult], Any], metric)(run)\n                    if isinstance(m, dict):\n                        row.update(m)\n                    else:\n                        row[\"metric\"] = m\n\n            if y:\n                try:\n                    import numpy as _np  # local import to avoid hard dep at module import\n                except Exception:  # pragma: no cover\n                    _np = None  # type: ignore[assignment]\n\n                ts = run.traces\n                # pick x axis name\n                xname = getattr(ts.x, \"name\", \"time\")\n                for name in y:\n                    vals = ts[name].values\n                    if sample_at is not None and _np is not None and xname.lower() == \"time\":\n                        t = ts[xname].values\n                        row[name] = float(_np.interp(sample_at, t, vals))\n                    else:\n                        row[name] = (\n                            float(vals[-1]) if len(vals) else _np.nan if _np is not None else 0.0\n                        )\n            rows.append(row)\n        if pd is None:\n            return _MiniDataFrame(rows)\n        return pd.DataFrame(rows)\n\n    def to_csv(\n        self,\n        path: str,\n        metric: (\n            Callable[[AnalysisResult], float | dict[str, Any]]\n            | TMapping[str, Callable[[AnalysisResult], Any]]\n            | None\n        ) = None,\n        *,\n        trial_name: str = \"trial\",\n        param_prefix: str = \"\",\n        y: Sequence[str] | None = None,\n        sample_at: float | None = None,\n        columns: Sequence[str] | None = None,\n        index: bool = False,\n        **to_csv_kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Write the Monte Carlo per-trial table to CSV.\n\n        - `path`: output file path (passed to pandas.DataFrame.to_csv).\n        - `metric`, `trial_name`, `param_prefix`, `y`, `sample_at` are forwarded\n          to :meth:`to_dataframe` and behave the same.\n        - `columns`: optional sequence of column names to keep (order preserved).\n        - `index`: whether to write the DataFrame index (default False).\n        - `to_csv_kwargs`: additional keyword args passed to pandas.DataFrame.to_csv.\n\n        Raises RuntimeError if pandas is not available.\n        \"\"\"\n        try:\n            importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\"pandas is required for MonteCarloResult.to_csv()\") from exc\n\n        df = self.to_dataframe(\n            metric=metric,\n            trial_name=trial_name,\n            param_prefix=param_prefix,\n            y=y,\n            sample_at=sample_at,\n        )\n        if columns is not None:\n            df = df.loc[:, list(columns)]\n        df.to_csv(path, index=index, **to_csv_kwargs)\n\n    def save_samples_csv(\n        self, path: str, *, param_prefix: str = \"\", index: bool = False, **to_csv_kwargs: Any\n    ) -&gt; None:\n        \"\"\"Write only the sampled parameters (and trial index) to CSV.\n\n        This is a convenience helper that writes the per-trial sampled parameters\n        (the entries produced when generating the Monte Carlo `samples`) to a CSV\n        file. Columns are the sampled parameter names (optionally prefixed) and\n        the trial column named 'trial'.\n        \"\"\"\n        try:\n            importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\n                \"pandas is required for MonteCarloResult.save_samples_csv()\"\n            ) from exc\n\n        df = self.to_dataframe(metric=None, trial_name=\"trial\", param_prefix=param_prefix, y=None)\n        df.to_csv(path, index=index, **to_csv_kwargs)\n\n    def save_manifest_csv(self, path: str, *, index: bool = False, **to_csv_kwargs: Any) -&gt; None:\n        \"\"\"Write a small manifest describing the varied parameters to CSV.\n\n        The manifest columns are: label, nominal, dist. The manifest is taken from\n        `mapping_manifest` populated by the `monte_carlo` helper when available.\n        \"\"\"\n        try:\n            importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\n                \"pandas is required for MonteCarloResult.save_manifest_csv()\"\n            ) from exc\n\n        if not self.mapping_manifest:\n            # nothing to write\n            return\n\n        import pandas as pd  # local import; optional runtime dependency\n\n        df = pd.DataFrame(self.mapping_manifest, columns=[\"label\", \"nominal\", \"dist\"])\n        df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.result_handles","title":"<code>result_handles()</code>","text":"<p>Return the list of ResultHandle objects backing each run (if available).</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def result_handles(self) -&gt; list[ResultHandle]:\n    \"\"\"Return the list of ResultHandle objects backing each run (if available).\"\"\"\n\n    return list(self.handles or [])\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.save_manifest_csv","title":"<code>save_manifest_csv(path, *, index=False, **to_csv_kwargs)</code>","text":"<p>Write a small manifest describing the varied parameters to CSV.</p> <p>The manifest columns are: label, nominal, dist. The manifest is taken from <code>mapping_manifest</code> populated by the <code>monte_carlo</code> helper when available.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def save_manifest_csv(self, path: str, *, index: bool = False, **to_csv_kwargs: Any) -&gt; None:\n    \"\"\"Write a small manifest describing the varied parameters to CSV.\n\n    The manifest columns are: label, nominal, dist. The manifest is taken from\n    `mapping_manifest` populated by the `monte_carlo` helper when available.\n    \"\"\"\n    try:\n        importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\n            \"pandas is required for MonteCarloResult.save_manifest_csv()\"\n        ) from exc\n\n    if not self.mapping_manifest:\n        # nothing to write\n        return\n\n    import pandas as pd  # local import; optional runtime dependency\n\n    df = pd.DataFrame(self.mapping_manifest, columns=[\"label\", \"nominal\", \"dist\"])\n    df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.save_samples_csv","title":"<code>save_samples_csv(path, *, param_prefix='', index=False, **to_csv_kwargs)</code>","text":"<p>Write only the sampled parameters (and trial index) to CSV.</p> <p>This is a convenience helper that writes the per-trial sampled parameters (the entries produced when generating the Monte Carlo <code>samples</code>) to a CSV file. Columns are the sampled parameter names (optionally prefixed) and the trial column named 'trial'.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def save_samples_csv(\n    self, path: str, *, param_prefix: str = \"\", index: bool = False, **to_csv_kwargs: Any\n) -&gt; None:\n    \"\"\"Write only the sampled parameters (and trial index) to CSV.\n\n    This is a convenience helper that writes the per-trial sampled parameters\n    (the entries produced when generating the Monte Carlo `samples`) to a CSV\n    file. Columns are the sampled parameter names (optionally prefixed) and\n    the trial column named 'trial'.\n    \"\"\"\n    try:\n        importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\n            \"pandas is required for MonteCarloResult.save_samples_csv()\"\n        ) from exc\n\n    df = self.to_dataframe(metric=None, trial_name=\"trial\", param_prefix=param_prefix, y=None)\n    df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.to_csv","title":"<code>to_csv(path, metric=None, *, trial_name='trial', param_prefix='', y=None, sample_at=None, columns=None, index=False, **to_csv_kwargs)</code>","text":"<p>Write the Monte Carlo per-trial table to CSV.</p> <ul> <li><code>path</code>: output file path (passed to pandas.DataFrame.to_csv).</li> <li><code>metric</code>, <code>trial_name</code>, <code>param_prefix</code>, <code>y</code>, <code>sample_at</code> are forwarded   to :meth:<code>to_dataframe</code> and behave the same.</li> <li><code>columns</code>: optional sequence of column names to keep (order preserved).</li> <li><code>index</code>: whether to write the DataFrame index (default False).</li> <li><code>to_csv_kwargs</code>: additional keyword args passed to pandas.DataFrame.to_csv.</li> </ul> <p>Raises RuntimeError if pandas is not available.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def to_csv(\n    self,\n    path: str,\n    metric: (\n        Callable[[AnalysisResult], float | dict[str, Any]]\n        | TMapping[str, Callable[[AnalysisResult], Any]]\n        | None\n    ) = None,\n    *,\n    trial_name: str = \"trial\",\n    param_prefix: str = \"\",\n    y: Sequence[str] | None = None,\n    sample_at: float | None = None,\n    columns: Sequence[str] | None = None,\n    index: bool = False,\n    **to_csv_kwargs: Any,\n) -&gt; None:\n    \"\"\"Write the Monte Carlo per-trial table to CSV.\n\n    - `path`: output file path (passed to pandas.DataFrame.to_csv).\n    - `metric`, `trial_name`, `param_prefix`, `y`, `sample_at` are forwarded\n      to :meth:`to_dataframe` and behave the same.\n    - `columns`: optional sequence of column names to keep (order preserved).\n    - `index`: whether to write the DataFrame index (default False).\n    - `to_csv_kwargs`: additional keyword args passed to pandas.DataFrame.to_csv.\n\n    Raises RuntimeError if pandas is not available.\n    \"\"\"\n    try:\n        importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\"pandas is required for MonteCarloResult.to_csv()\") from exc\n\n    df = self.to_dataframe(\n        metric=metric,\n        trial_name=trial_name,\n        param_prefix=param_prefix,\n        y=y,\n        sample_at=sample_at,\n    )\n    if columns is not None:\n        df = df.loc[:, list(columns)]\n    df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.to_dataframe","title":"<code>to_dataframe(metric=None, *, trial_name='trial', param_prefix='', y=None, sample_at=None)</code>","text":"Returns a per-trial DataFrame with columns <ul> <li>trial (index within this Monte Carlo run)</li> <li>one column per sampled parameter (from <code>samples</code>), optionally prefixed</li> <li>optional metric columns computed from each AnalysisResult</li> <li>optional raw trace columns (final value or sampled at <code>sample_at</code> seconds)</li> </ul> metric <ul> <li>callable \u2192 result stored in column 'metric' (float or scalar)</li> <li>mapping name-&gt;callable \u2192 adds one column per metric name</li> </ul> <p>y: list of trace names to extract values for each run. If <code>sample_at</code> is given,    the value is linearly interpolated at t=sample_at using the run's time axis;    otherwise, the last value in the trace is used.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def to_dataframe(\n    self,\n    metric: (\n        Callable[[AnalysisResult], float | dict[str, Any]]\n        | TMapping[str, Callable[[AnalysisResult], Any]]\n        | None\n    ) = None,\n    *,\n    trial_name: str = \"trial\",\n    param_prefix: str = \"\",\n    y: Sequence[str] | None = None,\n    sample_at: float | None = None,\n) -&gt; Any:\n    \"\"\"\n    Returns a per-trial DataFrame with columns:\n      - trial (index within this Monte Carlo run)\n      - one column per sampled parameter (from `samples`), optionally prefixed\n      - optional metric columns computed from each AnalysisResult\n      - optional raw trace columns (final value or sampled at `sample_at` seconds)\n\n    metric:\n      - callable \u2192 result stored in column 'metric' (float or scalar)\n      - mapping name-&gt;callable \u2192 adds one column per metric name\n    y: list of trace names to extract values for each run. If `sample_at` is given,\n       the value is linearly interpolated at t=sample_at using the run's time axis;\n       otherwise, the last value in the trace is used.\n    \"\"\"\n    try:\n        pd: Any = importlib.import_module(\"pandas\")\n    except Exception:  # pragma: no cover\n        pd = None\n\n    rows: list[dict[str, Any]] = []\n    for i, (s, run) in enumerate(zip(self.samples, self.runs, strict=False)):\n        # copy sampled params; optionally add prefix\n        if param_prefix:\n            row = {f\"{param_prefix}{k}\": v for k, v in s.items()}\n        else:\n            row = dict(s)\n        row[trial_name] = i\n        if metric is not None:\n            if hasattr(metric, \"items\"):\n                for name, fn in cast(\n                    TMapping[str, Callable[[AnalysisResult], Any]], metric\n                ).items():\n                    row[name] = fn(run)\n            else:\n                m = cast(Callable[[AnalysisResult], Any], metric)(run)\n                if isinstance(m, dict):\n                    row.update(m)\n                else:\n                    row[\"metric\"] = m\n\n        if y:\n            try:\n                import numpy as _np  # local import to avoid hard dep at module import\n            except Exception:  # pragma: no cover\n                _np = None  # type: ignore[assignment]\n\n            ts = run.traces\n            # pick x axis name\n            xname = getattr(ts.x, \"name\", \"time\")\n            for name in y:\n                vals = ts[name].values\n                if sample_at is not None and _np is not None and xname.lower() == \"time\":\n                    t = ts[xname].values\n                    row[name] = float(_np.interp(sample_at, t, vals))\n                else:\n                    row[name] = (\n                        float(vals[-1]) if len(vals) else _np.nan if _np is not None else 0.0\n                    )\n        rows.append(row)\n    if pd is None:\n        return _MiniDataFrame(rows)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.OvershootSpec","title":"<code>OvershootSpec</code>  <code>dataclass</code>","text":"<p>Measure peak overshoot relative to a target value.</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass OvershootSpec:\n    \"\"\"Measure peak overshoot relative to a target value.\"\"\"\n\n    name: str\n    signal: str\n    target: float\n    reference: float | None = None\n    percent: bool = True\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.PhaseMarginSpec","title":"<code>PhaseMarginSpec</code>  <code>dataclass</code>","text":"<p>Phase margin at unity-gain crossover of H = numerator/denominator.</p> <p>Returns the classical PM = 180 + angle(H) [deg] at |H| = 1.</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass PhaseMarginSpec:\n    \"\"\"Phase margin at unity-gain crossover of H = numerator/denominator.\n\n    Returns the classical PM = 180 + angle(H) [deg] at |H| = 1.\n    \"\"\"\n\n    name: str\n    numerator: str\n    denominator: str\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.RiseTimeSpec","title":"<code>RiseTimeSpec</code>  <code>dataclass</code>","text":"<p>10-90 (or custom) rise time between threshold crossings.</p> <p>Computes the time difference between the first crossings of low and high thresholds, where thresholds are defined relative to baseline/reference and target.</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass RiseTimeSpec:\n    \"\"\"10-90 (or custom) rise time between threshold crossings.\n\n    Computes the time difference between the first crossings of low and high\n    thresholds, where thresholds are defined relative to baseline/reference and\n    target.\n    \"\"\"\n\n    name: str\n    signal: str\n    target: float | None = None\n    reference: float | None = None\n    low_pct: float = 0.1\n    high_pct: float = 0.9\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.SettlingTimeSpec","title":"<code>SettlingTimeSpec</code>  <code>dataclass</code>","text":"<p>Measure when a signal stays within a tolerance band.</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass SettlingTimeSpec:\n    \"\"\"Measure when a signal stays within a tolerance band.\"\"\"\n\n    name: str\n    signal: str\n    target: float\n    tolerance: float\n    tolerance_kind: Literal[\"abs\", \"pct\"] = \"pct\"\n    start_time: float = 0.0\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.THDSpec","title":"<code>THDSpec</code>  <code>dataclass</code>","text":"<p>Total Harmonic Distortion of a steady-state tone.</p> <p>Returns THD in percent. Fundamental can be provided (f0); otherwise the dominant bin (ignoring DC) is used. Uses a Hann window by default via FFT helper.</p> Source code in <code>spicelab/analysis/measure.py</code> <pre><code>@dataclass(frozen=True)\nclass THDSpec:\n    \"\"\"Total Harmonic Distortion of a steady-state tone.\n\n    Returns THD in percent. Fundamental can be provided (f0); otherwise the\n    dominant bin (ignoring DC) is used. Uses a Hann window by default via FFT helper.\n    \"\"\"\n\n    name: str\n    signal: str\n    harmonics: int = 5\n    f0: float | None = None\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.amplitude_spectrum","title":"<code>amplitude_spectrum(x, fs, *, win='hann')</code>","text":"<p>Return (freq, |X(f)|) using rfft_coherent.</p> <p>The magnitude is 2*|FFT|/sum(window) as in rfft_coherent().</p> Source code in <code>spicelab/analysis/signal.py</code> <pre><code>def amplitude_spectrum(\n    x: np.ndarray, fs: float, *, win: WindowKind = \"hann\"\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Return (freq, |X(f)|) using rfft_coherent.\n\n    The magnitude is 2*|FFT|/sum(window) as in rfft_coherent().\n    \"\"\"\n    res = rfft_coherent(x, fs, win=win)\n    mag = np.abs(res.spectrum)\n    # fix DC and Nyquist scaling (factor 2 not applied there in one-sided spectrum)\n    if mag.size &gt; 0:\n        mag[0] = np.abs(np.fft.rfft(x * window(x.size, win))[0]) / np.sum(window(x.size, win))\n    if mag.size &gt; 2 and np.isclose(res.freq[-1], fs / 2):\n        mag[-1] = np.abs(np.fft.rfft(x * window(x.size, win))[-1]) / np.sum(window(x.size, win))\n    return res.freq, mag\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.measure_job_result","title":"<code>measure_job_result(result, specs, *, return_as='python', param_prefix='param_')</code>","text":"<p>Evaluate measurement <code>specs</code> for each run in a JobResult and aggregate rows.</p> <p>Each output row includes the measurement fields plus the sweep parameters from the corresponding combo, prefixed by <code>param_prefix</code> (set to None to avoid prefixing). The return type mirrors :func:<code>spicelab.analysis.measure.measure</code> (polars or list[dict]).</p> Source code in <code>spicelab/analysis/pipeline.py</code> <pre><code>def measure_job_result(\n    result: JobResult,\n    specs: Sequence[Spec],\n    *,\n    return_as: Literal[\"python\", \"polars\"] = \"python\",\n    param_prefix: str | None = \"param_\",\n) -&gt; Any:\n    \"\"\"Evaluate measurement ``specs`` for each run in a JobResult and aggregate rows.\n\n    Each output row includes the measurement fields plus the sweep parameters from the\n    corresponding combo, prefixed by ``param_prefix`` (set to None to avoid prefixing).\n    The return type mirrors :func:`spicelab.analysis.measure.measure` (polars or list[dict]).\n    \"\"\"\n    all_rows: list[dict[str, Any]] = []\n    for run in result.runs:\n        ds = run.handle.dataset()\n        rows = measure(ds, specs, return_as=\"python\")\n        params = _flatten_params(run.combo, prefix=param_prefix)\n        for r in rows:\n            all_rows.append({**params, **r})\n    if return_as == \"python\":\n        return all_rows\n    try:\n        import polars as pl\n    except Exception as exc:  # pragma: no cover - optional dependency\n        raise RuntimeError(\"polars is required when return_as='polars'\") from exc\n    # For polars, apply a stable column ordering: param_* first (sorted),\n    # then measure fields via CLI's order\n    from ..cli.measure import _order_columns as _cli_order_columns\n\n    # Union of keys\n    seen: set[str] = set()\n    keys: list[str] = []\n    for r in all_rows:\n        for k in r.keys():\n            if k not in seen:\n                seen.add(k)\n                keys.append(k)\n    params_cols = sorted(\n        [k for k in keys if isinstance(k, str) and k.startswith(str(param_prefix or \"param_\"))]\n    )\n    measure_cols = [k for k in keys if k not in params_cols]\n    ordered_measure = _cli_order_columns([c for c in measure_cols if isinstance(c, str)])\n    cols = params_cols + ordered_measure\n    df = pl.DataFrame(all_rows)\n    # Keep only existing columns, in the desired order\n    existing = [c for c in cols if c in df.columns]\n    return df.select(existing)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.monte_carlo","title":"<code>monte_carlo(circuit, mapping, n, seed=None, label_fn=None, workers=1, progress=None, *, analyses=None, engine='ngspice', cache_dir='.spicelab_cache', reuse_cache=True)</code>","text":"<p>Executa Monte Carlo variando valores dos componentes conforme distribui\u00e7\u00f5es.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def monte_carlo(\n    circuit: Circuit,\n    mapping: Mapping[Component, Dist],\n    n: int,\n    seed: int | None = None,\n    label_fn: Callable[[Component], str] | None = None,\n    workers: int = 1,\n    progress: bool | Callable[[int, int], None] | None = None,\n    *,\n    analyses: Sequence[AnalysisSpec] | None = None,\n    engine: EngineName = \"ngspice\",\n    cache_dir: str | Path | None = \".spicelab_cache\",\n    reuse_cache: bool = True,\n) -&gt; MonteCarloResult:\n    \"\"\"\n    Executa Monte Carlo variando valores dos componentes conforme distribui\u00e7\u00f5es.\n    \"\"\"\n    if analyses is None:\n        raise ValueError(\"Provide 'analyses' when running monte_carlo\")\n\n    rnd = _random.Random(seed)\n\n    def _label(c: Component) -&gt; str:\n        if label_fn:\n            return label_fn(c)\n        return f\"{type(c).__name__}.{c.ref}\"\n\n    comps: list[Component] = list(mapping.keys())\n    nominals: list[float] = [_as_float(c.value) for c in comps]\n    dists: list[Dist] = [mapping[c] for c in comps]\n\n    ref_lookup: dict[Component, str] = {}\n    for comp in comps:\n        ref = getattr(comp, \"ref\", None)\n        if ref is None:\n            raise ValueError(\"All components in mapping must have .ref for Monte Carlo jobs\")\n        ref_lookup[comp] = str(ref)\n\n    samples: list[dict[str, float]] = []\n    combos: list[dict[str, float]] = []\n    for _ in range(n):\n        s: dict[str, float] = {}\n        combo: dict[str, float] = {}\n        for comp, nominal, dist in zip(comps, nominals, dists, strict=False):\n            sampled = dist.sample(nominal, rnd)\n            s[_label(comp)] = sampled\n            combo[ref_lookup[comp]] = sampled\n        samples.append(s)\n        combos.append(combo)\n\n    # build optional manifest: list of (label, nominal, dist_repr)\n    manifest: list[tuple[str, float, str]] = []\n    for c, nom, d in zip(comps, nominals, dists, strict=False):\n        try:\n            d_repr = repr(d)\n        except Exception:\n            d_repr = type(d).__name__\n        manifest.append((_label(c), nom, d_repr))\n\n    if n &lt;= 0:\n        return MonteCarloResult(\n            samples=samples,\n            runs=[],\n            mapping_manifest=manifest,\n            handles=[],\n            job=None,\n        )\n\n    job = Job(\n        circuit=circuit,\n        analyses=list(analyses),\n        engine=engine,\n        combos=tuple(dict(combo) for combo in combos),\n    )\n    job_result = run_job(\n        job,\n        cache_dir=cache_dir,\n        workers=workers,\n        progress=progress,\n        reuse_cache=reuse_cache,\n    )\n    handles: list[ResultHandle] = []\n    analysis_runs: list[AnalysisResult] = []\n    for job_run in job_result.runs:\n        handles.append(job_run.handle)\n        analysis_runs.append(_handle_to_analysis_result(job_run.handle))\n    if len(analysis_runs) != len(samples):\n        raise RuntimeError(\"Mismatch between Monte Carlo samples and job results\")\n    return MonteCarloResult(\n        samples=samples,\n        runs=analysis_runs,\n        mapping_manifest=manifest,\n        handles=handles,\n        job=job_result,\n    )\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.power_spectral_density","title":"<code>power_spectral_density(x, fs, *, win='hann')</code>","text":"<p>Return (freq, PSD) with a simple window-energy normalization.</p> <p>PSD here is magnitude-squared normalized by ENBW of the window to yield units ~ V^2/Hz.</p> Source code in <code>spicelab/analysis/signal.py</code> <pre><code>def power_spectral_density(\n    x: np.ndarray, fs: float, *, win: WindowKind = \"hann\"\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Return (freq, PSD) with a simple window-energy normalization.\n\n    PSD here is magnitude-squared normalized by ENBW of the window to yield units ~ V^2/Hz.\n    \"\"\"\n    n = x.size\n    if n == 0:\n        raise ValueError(\"x must be non-empty\")\n    w = window(n, win)\n    enbw = fs * np.sum(w**2) / (np.sum(w) ** 2)\n    res = rfft_coherent(x, fs, win=win)\n    psd = (np.abs(res.spectrum) ** 2) / enbw\n    return res.freq, psd\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.rfft_coherent","title":"<code>rfft_coherent(x, fs, *, win='hann')</code>","text":"<p>One-sided FFT with simple coherent gain correction.</p>"},{"location":"reference/analysis/#spicelab.analysis.rfft_coherent--parameters","title":"Parameters","text":"<p>x: input samples (1D) fs: sample rate in Hz win: window type</p>"},{"location":"reference/analysis/#spicelab.analysis.rfft_coherent--notes","title":"Notes","text":"<ul> <li>Applies window and divides by sum(window) to correct coherent gain (CG).</li> <li>Returns frequency axis (0..fs/2) and complex spectrum (one-sided, DC..Nyquist).</li> </ul> Source code in <code>spicelab/analysis/signal.py</code> <pre><code>def rfft_coherent(x: np.ndarray, fs: float, *, win: WindowKind = \"hann\") -&gt; FFTResult:\n    \"\"\"One-sided FFT with simple coherent gain correction.\n\n    Parameters\n    ----------\n    x: input samples (1D)\n    fs: sample rate in Hz\n    win: window type\n\n    Notes\n    -----\n    - Applies window and divides by sum(window) to correct coherent gain (CG).\n    - Returns frequency axis (0..fs/2) and complex spectrum (one-sided, DC..Nyquist).\n    \"\"\"\n    if x.ndim != 1:\n        raise ValueError(\"x must be 1D\")\n    n = x.size\n    if n == 0:\n        raise ValueError(\"x must be non-empty\")\n    w = window(n, win)\n    cg = np.sum(w)\n    xw = x * w\n    spec = np.fft.rfft(xw) / cg * 2.0  # scale to roughly preserve amplitude (except DC/Nyquist)\n    freq = np.fft.rfftfreq(n, d=1.0 / fs)\n    return FFTResult(freq=freq, spectrum=spec)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_and_measure","title":"<code>run_and_measure(job, specs, *, cache_dir='.spicelab_cache', workers=1, reuse_cache=True, return_as='python', param_prefix='param_')</code>","text":"<p>Execute a job with the orchestrator and measure outputs for each combo.</p> <p>Convenience wrapper around :func:<code>run_job</code> + :func:<code>measure_job_result</code>.</p> Source code in <code>spicelab/analysis/pipeline.py</code> <pre><code>def run_and_measure(\n    job: Job,\n    specs: Sequence[Spec],\n    *,\n    cache_dir: str | None = \".spicelab_cache\",\n    workers: int = 1,\n    reuse_cache: bool = True,\n    return_as: Literal[\"python\", \"polars\"] = \"python\",\n    param_prefix: str | None = \"param_\",\n) -&gt; Any:\n    \"\"\"Execute a job with the orchestrator and measure outputs for each combo.\n\n    Convenience wrapper around :func:`run_job` + :func:`measure_job_result`.\n    \"\"\"\n    jr = run_job(job, cache_dir=cache_dir, workers=workers, reuse_cache=reuse_cache)\n    return measure_job_result(jr, specs, return_as=return_as, param_prefix=param_prefix)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_param_grid","title":"<code>run_param_grid(circuit, variables, analyses, *, engine='ngspice', progress=None, cache_dir=None, workers=1, reuse_cache=True)</code>","text":"<p>Run a Cartesian product of component.value assignments.</p> <p>variables: sequence of (component, values) pairs.</p> Source code in <code>spicelab/analysis/sweep_grid.py</code> <pre><code>def run_param_grid(\n    circuit: object,\n    variables: Sequence[tuple[Component, Sequence[str | float]]],\n    analyses: Sequence[AnalysisSpec],\n    *,\n    engine: EngineName = \"ngspice\",\n    progress: bool | Callable[[int, int], None] | None = None,\n    cache_dir: str | Path | None = None,\n    workers: int = 1,\n    reuse_cache: bool = True,\n) -&gt; GridResult:\n    \"\"\"Run a Cartesian product of component.value assignments.\n\n    variables: sequence of (component, values) pairs.\n    \"\"\"\n\n    # Prepare original values to restore later\n    var_map: dict[str, list[str | float]] = {}\n    for comp, vals in variables:\n        var_map[str(comp.ref)] = list(vals)\n\n    sweep_spec = SweepSpec(variables=var_map)\n    job = run_simulation(\n        circuit,\n        analyses,\n        sweep=sweep_spec,\n        engine=engine,\n        progress=progress,\n        cache_dir=cache_dir,\n        workers=workers,\n        reuse_cache=reuse_cache,\n    )\n    if not isinstance(job, JobResult):\n        raise RuntimeError(\"Expected JobResult from run_simulation when sweep is provided\")\n    grid_runs: list[GridRun] = []\n    for job_run in job.runs:\n        grid_runs.append(GridRun(combo=dict(job_run.combo), handle=job_run.handle))\n\n    return GridResult(runs=grid_runs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_value_sweep","title":"<code>run_value_sweep(circuit, component, values, analyses, *, engine='ngspice', progress=None, cache_dir=None, workers=1, reuse_cache=True)</code>","text":"<p>Run multiple simulations varying a single component value.</p> <ul> <li>Mutates component.value for each run; restores the original value at the end.</li> <li>Uses the unified engine API (get_simulator().run(...)).</li> <li>Returns lightweight handles; you can pull xarray datasets from each when needed.</li> </ul> Source code in <code>spicelab/analysis/sweep_grid.py</code> <pre><code>def run_value_sweep(\n    circuit: object,\n    component: Component,\n    values: Sequence[str | float],\n    analyses: Sequence[AnalysisSpec],\n    *,\n    engine: EngineName = \"ngspice\",\n    progress: bool | Callable[[int, int], None] | None = None,\n    cache_dir: str | Path | None = None,\n    workers: int = 1,\n    reuse_cache: bool = True,\n) -&gt; SweepResult:\n    \"\"\"Run multiple simulations varying a single component value.\n\n    - Mutates component.value for each run; restores the original value at the end.\n    - Uses the unified engine API (get_simulator().run(...)).\n    - Returns lightweight handles; you can pull xarray datasets from each when needed.\n    \"\"\"\n\n    sweep_spec = SweepSpec(variables={str(component.ref): list(values)})\n    result = run_simulation(\n        circuit,\n        analyses,\n        sweep=sweep_spec,\n        engine=engine,\n        progress=progress,\n        cache_dir=cache_dir,\n        workers=workers,\n        reuse_cache=reuse_cache,\n    )\n    if not isinstance(result, JobResult):\n        raise RuntimeError(\"Expected JobResult from run_simulation when sweep is provided\")\n    runs: list[SweepRun] = []\n    for job_run in result.runs:\n        value = job_run.combo.get(str(component.ref))\n        runs.append(SweepRun(value=value if value is not None else \"\", handle=job_run.handle))\n    return SweepResult(component_ref=str(component.ref), values=list(values), runs=runs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.window","title":"<code>window(n, kind='hann')</code>","text":"<p>Return a window with n points.</p> <ul> <li>rect: ones</li> <li>hann: 0.5 * (1 - cos(2pin/N))</li> <li>hamming: 0.54 - 0.46 * cos(2pin/N)</li> <li>blackman: 0.42 - 0.5cos(2pin/N) + 0.08cos(4pin/N)</li> </ul> Source code in <code>spicelab/analysis/signal.py</code> <pre><code>def window(n: int, kind: WindowKind = \"hann\") -&gt; np.ndarray:\n    \"\"\"Return a window with n points.\n\n    - rect: ones\n    - hann: 0.5 * (1 - cos(2*pi*n/N))\n    - hamming: 0.54 - 0.46 * cos(2*pi*n/N)\n    - blackman: 0.42 - 0.5*cos(2*pi*n/N) + 0.08*cos(4*pi*n/N)\n    \"\"\"\n    if n &lt;= 0:\n        raise ValueError(\"window length must be &gt; 0\")\n    if kind == \"rect\":\n        return np.ones(n, dtype=float)\n    k = np.arange(n, dtype=float)\n    if kind == \"hann\":\n        return 0.5 * (1.0 - np.cos(2.0 * np.pi * k / (n - 1)))\n    if kind == \"hamming\":\n        return 0.54 - 0.46 * np.cos(2.0 * np.pi * k / (n - 1))\n    if kind == \"blackman\":\n        return (\n            0.42\n            - 0.5 * np.cos(2.0 * np.pi * k / (n - 1))\n            + 0.08 * np.cos(4.0 * np.pi * k / (n - 1))\n        )\n    raise ValueError(f\"unsupported window '{kind}'\")\n</code></pre>"},{"location":"reference/core/","title":"Core API","text":""},{"location":"reference/core/#spicelab.core.Capacitor","title":"<code>Capacitor</code>","text":"<p>               Bases: <code>Component</code></p> <p>Capacitor de 2 terminais; portas: a (positivo), b (negativo).</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>Reference designator (e.g., \"1\" for C1)</p> required <code>value</code> <code>str | float</code> <p>Legacy stringly-typed value (backward compat)</p> <code>''</code> <code>capacitance</code> <code>float | ParameterRef | None</code> <p>Typed capacitance value (float or ParameterRef)</p> <code>None</code> <p>Use either <code>value</code> OR <code>capacitance</code>, not both.</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Capacitor(Component):\n    \"\"\"Capacitor de 2 terminais; portas: a (positivo), b (negativo).\n\n    Args:\n        ref: Reference designator (e.g., \"1\" for C1)\n        value: Legacy stringly-typed value (backward compat)\n        capacitance: Typed capacitance value (float or ParameterRef)\n\n    Use either `value` OR `capacitance`, not both.\n    \"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        value: str | float = \"\",\n        capacitance: float | ParameterRef | None = None,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self.capacitance = capacitance\n        self._ports = (Port(self, \"a\", PortRole.POSITIVE), Port(self, \"b\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        a, b = self.ports\n        # Use typed field if present, otherwise fall back to value\n        val = str(self.capacitance) if self.capacitance is not None else self.value\n        return f\"C{self.ref} {net_of(a)} {net_of(b)} {val}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit","title":"<code>Circuit</code>  <code>dataclass</code>","text":"<p>Logical circuit composed of components, nets and raw SPICE directives.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@dataclass\nclass Circuit:\n    \"\"\"Logical circuit composed of components, nets and raw SPICE directives.\"\"\"\n\n    name: str\n    _net_ids: dict[Net, int] = field(default_factory=dict, init=False)\n    _port_to_net: dict[Port, Net] = field(default_factory=dict, init=False)\n    _components: list[Component] = field(default_factory=list, init=False)\n    _directives: list[str] = field(default_factory=list, init=False)\n    # metadata captured when loading from existing netlists\n    _subckt_defs: dict[str, str] = field(default_factory=dict, init=False)\n    _subckt_instances: list[dict[str, object]] = field(default_factory=list, init=False)\n    _port_labels: dict[Port, str] = field(default_factory=dict, init=False)\n    # Union-Find for O(\u03b1(n)) net merging (M2 performance optimization)\n    _net_union: UnionFind[Net] = field(default_factory=UnionFind, init=False)\n    # Cache invalidation version counter\n    _cache_version: int = field(default=0, init=False)\n\n    # ----------------------------------------------------------------------------------\n    # Building blocks\n    # ----------------------------------------------------------------------------------\n    def add(self, *components: Component) -&gt; Circuit:\n        \"\"\"Append one or more components to the circuit.\"\"\"\n\n        self._components.extend(components)\n        return self\n\n    def add_directive(self, line: str) -&gt; Circuit:\n        \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n        self._directives.append(line.rstrip(\"\\n\"))\n        return self\n\n    def add_directive_once(self, line: str) -&gt; Circuit:\n        \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n        normalized = line.strip()\n        for existing in self._directives:\n            if existing.strip() == normalized:\n                return self\n        return self.add_directive(line)\n\n    def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n        \"\"\"Connect a port to another port or to a logical net.\n\n        Uses Union-Find for O(\u03b1(n)) amortized net merging (M2 optimization).\n        \"\"\"\n        self._invalidate_cache()\n\n        if isinstance(b, Port):\n            net_a = self._port_to_net.get(a)\n            net_b = self._port_to_net.get(b)\n\n            if net_a and net_b and net_a is not net_b:\n                # Merge using Union-Find: O(\u03b1(n)) instead of O(n)\n                # Ensure both nets are in union-find\n                if net_a not in self._net_union:\n                    is_named_a = getattr(net_a, \"name\", None) is not None\n                    self._net_union.make_set(net_a, net_a if is_named_a else None)\n                if net_b not in self._net_union:\n                    is_named_b = getattr(net_b, \"name\", None) is not None\n                    self._net_union.make_set(net_b, net_b if is_named_b else None)\n\n                # Prefer named net as canonical\n                prefer = None\n                if getattr(net_a, \"name\", None):\n                    prefer = net_a\n                elif getattr(net_b, \"name\", None):\n                    prefer = net_b\n\n                self._net_union.union(net_a, net_b, prefer=prefer)\n            else:\n                shared = net_a or net_b or Net()\n                self._port_to_net[a] = shared\n                self._port_to_net[b] = shared\n                # Register in union-find\n                if shared not in self._net_union:\n                    is_named = getattr(shared, \"name\", None) is not None\n                    self._net_union.make_set(shared, shared if is_named else None)\n            self._port_labels.pop(b, None)\n        else:\n            self._port_to_net[a] = b\n            # Register named net in union-find\n            if b not in self._net_union:\n                is_named = getattr(b, \"name\", None) is not None\n                self._net_union.make_set(b, b if is_named else None)\n        self._port_labels.pop(a, None)\n        return self\n\n    def _invalidate_cache(self) -&gt; None:\n        \"\"\"Invalidate cached properties when circuit is modified.\"\"\"\n        self._cache_version += 1\n        # Clear cached net IDs\n        self._net_ids.clear()\n\n    def connect_with_label(self, port: Port, net: Net, label: str | None = None) -&gt; Circuit:\n        \"\"\"Connect ``port`` to ``net`` while recording a display label.\"\"\"\n\n        self.connect(port, net)\n        if label:\n            self._port_labels[port] = label\n        return self\n\n    # ----------------------------------------------------------------------------------\n    # Net handling\n    # ----------------------------------------------------------------------------------\n    def _assign_node_ids(self) -&gt; None:\n        \"\"\"Assign node IDs, using Union-Find for canonical net resolution.\"\"\"\n        self._net_ids.clear()\n        self._net_ids[GND] = 0\n\n        next_id = 1\n        seen: set[Net] = {GND}\n\n        def canonical_nets_from_components() -&gt; Iterable[Net]:\n            for comp in self._components:\n                for port in comp.ports:\n                    net = self._port_to_net.get(port)\n                    if net is not None:\n                        # Use canonical net for proper merging\n                        yield self._get_canonical_net(net)\n\n        for net in canonical_nets_from_components():\n            if net in seen:\n                continue\n            seen.add(net)\n            if getattr(net, \"name\", None) and net.name != \"0\":\n                # preserve named nets but still assign an id for bookkeeping\n                self._net_ids[net] = next_id\n            else:\n                self._net_ids[net] = next_id\n            next_id += 1\n\n    def _net_of(self, port: Port) -&gt; str:\n        net = self._port_to_net.get(port)\n        if net is None:\n            raise ValueError(f\"Unconnected port: {port.owner.ref}.{port.name}\")\n\n        # Use Union-Find to get the canonical net (handles merged nets)\n        canonical_net = self._get_canonical_net(net)\n\n        if canonical_net is GND or getattr(canonical_net, \"name\", None) == \"0\":\n            return \"0\"\n\n        if getattr(canonical_net, \"name\", None):\n            return str(canonical_net.name)\n\n        node_id = self._net_ids.get(canonical_net)\n        if node_id is None:\n            raise RuntimeError(\"Node IDs not assigned\")\n        return str(node_id)\n\n    def _get_canonical_net(self, net: Net) -&gt; Net:\n        \"\"\"Get the canonical net for a possibly-merged net using Union-Find.\"\"\"\n        if net not in self._net_union:\n            return net\n        return self._net_union.get_canonical(net)\n\n    # ----------------------------------------------------------------------------------\n    # Netlist helpers\n    # ----------------------------------------------------------------------------------\n    def build_netlist(self) -&gt; str:\n        \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [f\"* {self.name}\"]\n\n        for comp in self._components:\n            card = comp.spice_card(self._net_of)\n            # components such as AnalogMux may emit multi-line cards\n            for ln in card.splitlines():\n                if ln.strip():\n                    lines.append(ln)\n\n        for directive in self._directives:\n            lines.extend(directive.splitlines())\n\n        if not any(line.strip().lower() == \".end\" for line in lines):\n            lines.append(\".end\")\n\n        return \"\\n\".join(lines) + \"\\n\"\n\n    def save_netlist(self, path: str | Path) -&gt; Path:\n        \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n        p = Path(path)\n        p.write_text(self.build_netlist(), encoding=\"utf-8\")\n        return p\n\n    # ----------------------------------------------------------------------------------\n    # Hash (deterministic) - part of M1 contract\n    # ----------------------------------------------------------------------------------\n    def hash(self, *, extra: dict[str, object] | None = None) -&gt; str:  # pragma: no cover - thin\n        \"\"\"Return a deterministic short hash for this circuit.\n\n        Wrapper around ``spicelab.core.types.circuit_hash`` so callers do not need\n        to import the helper directly. ``extra`` can include engine/version/analysis\n        args to bind caches firmly to execution context.\n        \"\"\"\n        from .types import circuit_hash  # local import to avoid cycle during module init\n\n        return circuit_hash(self, extra=extra)\n\n    # ----------------------------------------------------------------------------------\n    # Validation (M4 DX improvement)\n    # ----------------------------------------------------------------------------------\n    def validate(self, strict: bool = False) -&gt; ValidationResult:\n        \"\"\"Validate circuit topology and component values.\n\n        Performs checks:\n        - Ground reference exists\n        - No floating nodes (connected to only one component)\n        - No unusual component values\n        - No voltage source shorts (parallel voltage sources)\n\n        Args:\n            strict: If True, treat warnings as errors\n\n        Returns:\n            ValidationResult with errors and warnings\n\n        Example:\n            &gt;&gt;&gt; result = circuit.validate()\n            &gt;&gt;&gt; if result.has_issues():\n            ...     print(result)\n            &gt;&gt;&gt; if not result.is_valid:\n            ...     raise ValueError(\"Circuit has errors\")\n        \"\"\"\n        from ..validators.circuit_validation import validate_circuit\n\n        return validate_circuit(self, strict=strict)\n\n    # ----------------------------------------------------------------------------------\n    # Introspection helpers\n    # ----------------------------------------------------------------------------------\n    def _net_label(self, net: Net | None) -&gt; str:\n        if net is None:\n            return \"&lt;unconnected&gt;\"\n\n        # Use canonical net for merged nets\n        canonical = self._get_canonical_net(net)\n\n        if canonical is GND or getattr(canonical, \"name\", None) == \"0\":\n            return \"0\"\n        if getattr(canonical, \"name\", None):\n            return str(canonical.name)\n        node_id = self._net_ids.get(canonical)\n        if node_id is None:\n            self._assign_node_ids()\n            node_id = self._net_ids.get(canonical)\n        return f\"N{node_id:03d}\" if node_id is not None else \"&lt;unnamed&gt;\"\n\n    def summary(self) -&gt; str:\n        \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = []\n        warnings: list[str] = []\n\n        lines.append(f\"Circuit: {self.name}\")\n        lines.append(f\"Components ({len(self._components)}):\")\n\n        for comp in self._components:\n            port_descriptions: list[str] = []\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                label = self._port_labels.get(port) or self._net_label(net)\n                if label == \"&lt;unconnected&gt;\":\n                    warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n                port_descriptions.append(f\"{port.name}-&gt;{label}\")\n            port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n            lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n        net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n        if net_names:\n            lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n        if warnings:\n            lines.append(\"Warnings:\")\n            for msg in warnings:\n                lines.append(f\"  * {msg}\")\n        else:\n            lines.append(\"Warnings: none\")\n\n        return \"\\n\".join(lines)\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n        comp_ids: dict[Component, str] = {}\n        for idx, comp in enumerate(self._components, start=1):\n            comp_id = f\"comp_{idx}\"\n            comp_ids[comp] = comp_id\n            label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n            lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n        net_ids: dict[Net | None, str] = {}\n        net_counter = 1\n\n        def _net_node(net: Net | None) -&gt; str:\n            nonlocal net_counter\n            if net in net_ids:\n                return net_ids[net]\n            node_id = f\"net_{net_counter}\"\n            net_counter += 1\n            label = self._net_label(net)\n            shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n            net_ids[net] = node_id\n            lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n            return node_id\n\n        for comp in self._components:\n            comp_id = comp_ids[comp]\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                net_id = _net_node(net)\n                lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n        lines.append(\"}\")\n        return \"\\n\".join(lines)\n\n    # ----------------------------------------------------------------------------------\n    # Notebook-friendly helpers\n    # ----------------------------------------------------------------------------------\n    def connectivity_dataframe(self, *, sort: bool = True, include_type: bool = True):\n        \"\"\"Return a pandas DataFrame describing component/net connectivity.\n\n        Columns: ``component``, ``type`` (optional), ``port`` and ``net``. The\n        returned DataFrame is ideal for Jupyter notebooks where an interactive\n        table is easier to scan than the plain text summary.\n        \"\"\"\n\n        try:\n            import pandas as pd\n        except Exception as exc:  # pragma: no cover - optional dependency guard\n            raise RuntimeError(\"pandas is required for connectivity_dataframe()\") from exc\n\n        self._assign_node_ids()\n\n        rows: list[dict[str, object]] = []\n        for comp in self._components:\n            for order, port in enumerate(comp.ports):\n                net = self._port_to_net.get(port)\n                label = self._port_labels.get(port) or self._net_label(net)\n                rows.append(\n                    {\n                        \"component\": comp.ref,\n                        \"type\": type(comp).__name__,\n                        \"port\": port.name,\n                        \"net\": label,\n                        \"_order\": order,\n                    }\n                )\n\n        if not rows:\n            columns = [\"component\", \"port\", \"net\"]\n            if include_type:\n                columns.insert(1, \"type\")\n            return pd.DataFrame(columns=columns)\n\n        df = pd.DataFrame(rows)\n        if sort:\n            df = df.sort_values([\"component\", \"_order\", \"port\"]).reset_index(drop=True)\n        if not include_type:\n            df = df.drop(columns=[\"type\"])\n        return df.drop(columns=[\"_order\"])\n\n    def summary_table(self, *, indent: int = 2) -&gt; str:\n        \"\"\"Return a fixed-width table describing component connections.\"\"\"\n\n        df = self.connectivity_dataframe()\n        if df.empty:\n            return \"(circuit is empty)\"\n\n        headers = list(df.columns)\n        display_names = {col: col.capitalize() for col in headers}\n        widths = {\n            col: max(len(display_names[col]), *(len(str(val)) for val in df[col]))\n            for col in headers\n        }\n\n        def fmt_row(row: dict[str, object]) -&gt; str:\n            cells = [str(row[col]).ljust(widths[col]) for col in headers]\n            return \" \" * indent + \"  \".join(cells)\n\n        header_line = \" \" * indent + \"  \".join(\n            display_names[col].ljust(widths[col]) for col in headers\n        )\n        sep_line = \" \" * indent + \"  \".join(\"-\" * widths[col] for col in headers)\n        body = \"\\n\".join(fmt_row(df.iloc[idx]) for idx in range(len(df)))\n        return f\"{header_line}\\n{sep_line}\\n{body}\"\n\n    # ----------------------------------------------------------------------------------\n    # Netlist import\n    # ----------------------------------------------------------------------------------\n    @classmethod\n    def from_netlist(cls, path: str | Path) -&gt; Circuit:\n        \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n        p = Path(path)\n        text = p.read_text(encoding=\"utf-8\")\n\n        from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n        lines = preprocess_netlist(text)\n        ast = parse_lines_to_ast(lines)\n\n        name = p.stem\n        if lines and lines[0].lstrip().startswith(\"*\"):\n            maybe_title = lines[0].lstrip()[1:].strip()\n            if maybe_title:\n                name = maybe_title\n\n        circ = cls(name=name)\n\n        for node in ast:\n            kind_obj = node.get(\"type\")\n            kind = str(kind_obj) if isinstance(kind_obj, str) else None\n            raw_obj = node.get(\"raw\")\n            raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n            if kind == \"subckt\":\n                header = raw.splitlines()[0]\n                parts = header.split()\n                if len(parts) &gt;= 2:\n                    circ._subckt_defs[parts[1]] = raw\n                circ.add_directive(raw)\n                continue\n\n            if kind == \"comment\" or kind == \"directive\":\n                circ.add_directive(raw)\n                continue\n\n            if kind != \"component\":\n                continue\n\n            tokens_obj = node.get(\"tokens\")\n            tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n            if not tokens:\n                continue\n\n            card = tokens[0]\n            letter = cast(str | None, node.get(\"letter\"))\n            ref = cast(str | None, node.get(\"ref\"))\n\n            try:\n                comp = cls._component_from_tokens(letter, ref, tokens)\n                if comp is None:\n                    circ.add_directive(raw)\n                    continue\n                circ.add(comp)\n                circ._connect_from_tokens(comp, tokens[1:])\n                if letter == \"X\":\n                    circ._subckt_instances.append(\n                        {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                    )\n            except Exception as exc:  # pragma: no cover - defensive fallback\n                log.warning(\"Failed to parse component '%s': %s\", card, exc)\n                circ.add_directive(raw)\n\n        return circ\n\n    # ----------------------------------------------------------------------------------\n    # Helpers for from_netlist\n    # ----------------------------------------------------------------------------------\n    @staticmethod\n    def _component_from_tokens(\n        letter: str | None, ref: str | None, tokens: list[str]\n    ) -&gt; Component | None:\n        if not letter or not ref:\n            return None\n\n        letter = letter.upper()\n        value = \" \".join(tokens[3:]) if len(tokens) &gt; 3 else \"\"\n\n        if letter == \"R\":\n            return Resistor(ref=ref, value=value)\n        if letter == \"C\":\n            return Capacitor(ref=ref, value=value)\n        if letter == \"L\":\n            return Inductor(ref=ref, value=value)\n        if letter == \"V\":\n            return Vdc(ref=ref, value=value)\n        if letter == \"I\":\n            return Idc(ref=ref, value=value)\n        if letter == \"E\":\n            gain = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCVS(ref=ref, gain=gain)\n        if letter == \"G\":\n            gm = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCCS(ref=ref, gm=gm)\n        if letter == \"F\":\n            gain = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCCS(ref=ref, ctrl_vsrc=ctrl, gain=gain)\n        if letter == \"H\":\n            r = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCVS(ref=ref, ctrl_vsrc=ctrl, r=r)\n        if letter == \"D\":\n            model = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return Diode(ref=ref, model=model)\n        if letter == \"S\":\n            model = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VSwitch(ref=ref, model=model)\n        if letter == \"W\":\n            model = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return ISwitch(ref=ref, ctrl_vsrc=ctrl, model=model)\n\n        # Subcircuits and unsupported devices are preserved as directives\n        return None\n\n    def _connect_from_tokens(self, component: Component, node_tokens: list[str]) -&gt; None:\n        port_iter = iter(component.ports)\n        for node_name in node_tokens:\n            try:\n                port = next(port_iter)\n            except StopIteration:\n                break\n            net = self._get_or_create_net(node_name)\n            self.connect(port, net)\n\n    def _get_or_create_net(self, name: str) -&gt; Net:\n        if name == \"0\":\n            return GND\n        for net in self._port_to_net.values():\n            if getattr(net, \"name\", None) == name:\n                return net\n        new = Net(name)\n        return new\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.add","title":"<code>add(*components)</code>","text":"<p>Append one or more components to the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add(self, *components: Component) -&gt; Circuit:\n    \"\"\"Append one or more components to the circuit.\"\"\"\n\n    self._components.extend(components)\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.add_directive","title":"<code>add_directive(line)</code>","text":"<p>Append a raw SPICE directive (<code>.model</code>, <code>.param</code> ...).</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive(self, line: str) -&gt; Circuit:\n    \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n    self._directives.append(line.rstrip(\"\\n\"))\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.add_directive_once","title":"<code>add_directive_once(line)</code>","text":"<p>Add a directive if an identical line (ignoring whitespace) is absent.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive_once(self, line: str) -&gt; Circuit:\n    \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n    normalized = line.strip()\n    for existing in self._directives:\n        if existing.strip() == normalized:\n            return self\n    return self.add_directive(line)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.build_netlist","title":"<code>build_netlist()</code>","text":"<p>Return a SPICE netlist representation of this circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def build_netlist(self) -&gt; str:\n    \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [f\"* {self.name}\"]\n\n    for comp in self._components:\n        card = comp.spice_card(self._net_of)\n        # components such as AnalogMux may emit multi-line cards\n        for ln in card.splitlines():\n            if ln.strip():\n                lines.append(ln)\n\n    for directive in self._directives:\n        lines.extend(directive.splitlines())\n\n    if not any(line.strip().lower() == \".end\" for line in lines):\n        lines.append(\".end\")\n\n    return \"\\n\".join(lines) + \"\\n\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.connect","title":"<code>connect(a, b)</code>","text":"<p>Connect a port to another port or to a logical net.</p> <p>Uses Union-Find for O(\u03b1(n)) amortized net merging (M2 optimization).</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n    \"\"\"Connect a port to another port or to a logical net.\n\n    Uses Union-Find for O(\u03b1(n)) amortized net merging (M2 optimization).\n    \"\"\"\n    self._invalidate_cache()\n\n    if isinstance(b, Port):\n        net_a = self._port_to_net.get(a)\n        net_b = self._port_to_net.get(b)\n\n        if net_a and net_b and net_a is not net_b:\n            # Merge using Union-Find: O(\u03b1(n)) instead of O(n)\n            # Ensure both nets are in union-find\n            if net_a not in self._net_union:\n                is_named_a = getattr(net_a, \"name\", None) is not None\n                self._net_union.make_set(net_a, net_a if is_named_a else None)\n            if net_b not in self._net_union:\n                is_named_b = getattr(net_b, \"name\", None) is not None\n                self._net_union.make_set(net_b, net_b if is_named_b else None)\n\n            # Prefer named net as canonical\n            prefer = None\n            if getattr(net_a, \"name\", None):\n                prefer = net_a\n            elif getattr(net_b, \"name\", None):\n                prefer = net_b\n\n            self._net_union.union(net_a, net_b, prefer=prefer)\n        else:\n            shared = net_a or net_b or Net()\n            self._port_to_net[a] = shared\n            self._port_to_net[b] = shared\n            # Register in union-find\n            if shared not in self._net_union:\n                is_named = getattr(shared, \"name\", None) is not None\n                self._net_union.make_set(shared, shared if is_named else None)\n        self._port_labels.pop(b, None)\n    else:\n        self._port_to_net[a] = b\n        # Register named net in union-find\n        if b not in self._net_union:\n            is_named = getattr(b, \"name\", None) is not None\n            self._net_union.make_set(b, b if is_named else None)\n    self._port_labels.pop(a, None)\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.connect_with_label","title":"<code>connect_with_label(port, net, label=None)</code>","text":"<p>Connect <code>port</code> to <code>net</code> while recording a display label.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connect_with_label(self, port: Port, net: Net, label: str | None = None) -&gt; Circuit:\n    \"\"\"Connect ``port`` to ``net`` while recording a display label.\"\"\"\n\n    self.connect(port, net)\n    if label:\n        self._port_labels[port] = label\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.connectivity_dataframe","title":"<code>connectivity_dataframe(*, sort=True, include_type=True)</code>","text":"<p>Return a pandas DataFrame describing component/net connectivity.</p> <p>Columns: <code>component</code>, <code>type</code> (optional), <code>port</code> and <code>net</code>. The returned DataFrame is ideal for Jupyter notebooks where an interactive table is easier to scan than the plain text summary.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connectivity_dataframe(self, *, sort: bool = True, include_type: bool = True):\n    \"\"\"Return a pandas DataFrame describing component/net connectivity.\n\n    Columns: ``component``, ``type`` (optional), ``port`` and ``net``. The\n    returned DataFrame is ideal for Jupyter notebooks where an interactive\n    table is easier to scan than the plain text summary.\n    \"\"\"\n\n    try:\n        import pandas as pd\n    except Exception as exc:  # pragma: no cover - optional dependency guard\n        raise RuntimeError(\"pandas is required for connectivity_dataframe()\") from exc\n\n    self._assign_node_ids()\n\n    rows: list[dict[str, object]] = []\n    for comp in self._components:\n        for order, port in enumerate(comp.ports):\n            net = self._port_to_net.get(port)\n            label = self._port_labels.get(port) or self._net_label(net)\n            rows.append(\n                {\n                    \"component\": comp.ref,\n                    \"type\": type(comp).__name__,\n                    \"port\": port.name,\n                    \"net\": label,\n                    \"_order\": order,\n                }\n            )\n\n    if not rows:\n        columns = [\"component\", \"port\", \"net\"]\n        if include_type:\n            columns.insert(1, \"type\")\n        return pd.DataFrame(columns=columns)\n\n    df = pd.DataFrame(rows)\n    if sort:\n        df = df.sort_values([\"component\", \"_order\", \"port\"]).reset_index(drop=True)\n    if not include_type:\n        df = df.drop(columns=[\"type\"])\n    return df.drop(columns=[\"_order\"])\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.from_netlist","title":"<code>from_netlist(path)</code>  <code>classmethod</code>","text":"<p>Load a circuit from a plain SPICE netlist file.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@classmethod\ndef from_netlist(cls, path: str | Path) -&gt; Circuit:\n    \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n    p = Path(path)\n    text = p.read_text(encoding=\"utf-8\")\n\n    from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n    lines = preprocess_netlist(text)\n    ast = parse_lines_to_ast(lines)\n\n    name = p.stem\n    if lines and lines[0].lstrip().startswith(\"*\"):\n        maybe_title = lines[0].lstrip()[1:].strip()\n        if maybe_title:\n            name = maybe_title\n\n    circ = cls(name=name)\n\n    for node in ast:\n        kind_obj = node.get(\"type\")\n        kind = str(kind_obj) if isinstance(kind_obj, str) else None\n        raw_obj = node.get(\"raw\")\n        raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n        if kind == \"subckt\":\n            header = raw.splitlines()[0]\n            parts = header.split()\n            if len(parts) &gt;= 2:\n                circ._subckt_defs[parts[1]] = raw\n            circ.add_directive(raw)\n            continue\n\n        if kind == \"comment\" or kind == \"directive\":\n            circ.add_directive(raw)\n            continue\n\n        if kind != \"component\":\n            continue\n\n        tokens_obj = node.get(\"tokens\")\n        tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n        if not tokens:\n            continue\n\n        card = tokens[0]\n        letter = cast(str | None, node.get(\"letter\"))\n        ref = cast(str | None, node.get(\"ref\"))\n\n        try:\n            comp = cls._component_from_tokens(letter, ref, tokens)\n            if comp is None:\n                circ.add_directive(raw)\n                continue\n            circ.add(comp)\n            circ._connect_from_tokens(comp, tokens[1:])\n            if letter == \"X\":\n                circ._subckt_instances.append(\n                    {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                )\n        except Exception as exc:  # pragma: no cover - defensive fallback\n            log.warning(\"Failed to parse component '%s': %s\", card, exc)\n            circ.add_directive(raw)\n\n    return circ\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.hash","title":"<code>hash(*, extra=None)</code>","text":"<p>Return a deterministic short hash for this circuit.</p> <p>Wrapper around <code>spicelab.core.types.circuit_hash</code> so callers do not need to import the helper directly. <code>extra</code> can include engine/version/analysis args to bind caches firmly to execution context.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def hash(self, *, extra: dict[str, object] | None = None) -&gt; str:  # pragma: no cover - thin\n    \"\"\"Return a deterministic short hash for this circuit.\n\n    Wrapper around ``spicelab.core.types.circuit_hash`` so callers do not need\n    to import the helper directly. ``extra`` can include engine/version/analysis\n    args to bind caches firmly to execution context.\n    \"\"\"\n    from .types import circuit_hash  # local import to avoid cycle during module init\n\n    return circuit_hash(self, extra=extra)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.save_netlist","title":"<code>save_netlist(path)</code>","text":"<p>Persist the netlist to <code>path</code> and return the resolved <code>Path</code>.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def save_netlist(self, path: str | Path) -&gt; Path:\n    \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n    p = Path(path)\n    p.write_text(self.build_netlist(), encoding=\"utf-8\")\n    return p\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of the circuit and connectivity.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def summary(self) -&gt; str:\n    \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = []\n    warnings: list[str] = []\n\n    lines.append(f\"Circuit: {self.name}\")\n    lines.append(f\"Components ({len(self._components)}):\")\n\n    for comp in self._components:\n        port_descriptions: list[str] = []\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            label = self._port_labels.get(port) or self._net_label(net)\n            if label == \"&lt;unconnected&gt;\":\n                warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n            port_descriptions.append(f\"{port.name}-&gt;{label}\")\n        port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n        lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n    net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n    if net_names:\n        lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n    if warnings:\n        lines.append(\"Warnings:\")\n        for msg in warnings:\n            lines.append(f\"  * {msg}\")\n    else:\n        lines.append(\"Warnings: none\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.summary_table","title":"<code>summary_table(*, indent=2)</code>","text":"<p>Return a fixed-width table describing component connections.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def summary_table(self, *, indent: int = 2) -&gt; str:\n    \"\"\"Return a fixed-width table describing component connections.\"\"\"\n\n    df = self.connectivity_dataframe()\n    if df.empty:\n        return \"(circuit is empty)\"\n\n    headers = list(df.columns)\n    display_names = {col: col.capitalize() for col in headers}\n    widths = {\n        col: max(len(display_names[col]), *(len(str(val)) for val in df[col]))\n        for col in headers\n    }\n\n    def fmt_row(row: dict[str, object]) -&gt; str:\n        cells = [str(row[col]).ljust(widths[col]) for col in headers]\n        return \" \" * indent + \"  \".join(cells)\n\n    header_line = \" \" * indent + \"  \".join(\n        display_names[col].ljust(widths[col]) for col in headers\n    )\n    sep_line = \" \" * indent + \"  \".join(\"-\" * widths[col] for col in headers)\n    body = \"\\n\".join(fmt_row(df.iloc[idx]) for idx in range(len(df)))\n    return f\"{header_line}\\n{sep_line}\\n{body}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.to_dot","title":"<code>to_dot()</code>","text":"<p>Return a Graphviz DOT representation of the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n    comp_ids: dict[Component, str] = {}\n    for idx, comp in enumerate(self._components, start=1):\n        comp_id = f\"comp_{idx}\"\n        comp_ids[comp] = comp_id\n        label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n        lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n    net_ids: dict[Net | None, str] = {}\n    net_counter = 1\n\n    def _net_node(net: Net | None) -&gt; str:\n        nonlocal net_counter\n        if net in net_ids:\n            return net_ids[net]\n        node_id = f\"net_{net_counter}\"\n        net_counter += 1\n        label = self._net_label(net)\n        shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n        net_ids[net] = node_id\n        lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n        return node_id\n\n    for comp in self._components:\n        comp_id = comp_ids[comp]\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            net_id = _net_node(net)\n            lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n    lines.append(\"}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.validate","title":"<code>validate(strict=False)</code>","text":"<p>Validate circuit topology and component values.</p> <p>Performs checks: - Ground reference exists - No floating nodes (connected to only one component) - No unusual component values - No voltage source shorts (parallel voltage sources)</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, treat warnings as errors</p> <code>False</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with errors and warnings</p> Example <p>result = circuit.validate() if result.has_issues(): ...     print(result) if not result.is_valid: ...     raise ValueError(\"Circuit has errors\")</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def validate(self, strict: bool = False) -&gt; ValidationResult:\n    \"\"\"Validate circuit topology and component values.\n\n    Performs checks:\n    - Ground reference exists\n    - No floating nodes (connected to only one component)\n    - No unusual component values\n    - No voltage source shorts (parallel voltage sources)\n\n    Args:\n        strict: If True, treat warnings as errors\n\n    Returns:\n        ValidationResult with errors and warnings\n\n    Example:\n        &gt;&gt;&gt; result = circuit.validate()\n        &gt;&gt;&gt; if result.has_issues():\n        ...     print(result)\n        &gt;&gt;&gt; if not result.is_valid:\n        ...     raise ValueError(\"Circuit has errors\")\n    \"\"\"\n    from ..validators.circuit_validation import validate_circuit\n\n    return validate_circuit(self, strict=strict)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Inductor","title":"<code>Inductor</code>","text":"<p>               Bases: <code>Component</code></p> <p>Indutor de 2 terminais; portas: a (positivo), b (negativo).</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>Reference designator (e.g., \"1\" for L1)</p> required <code>value</code> <code>str | float</code> <p>Legacy stringly-typed value (backward compat)</p> <code>''</code> <code>inductance</code> <code>float | ParameterRef | None</code> <p>Typed inductance value (float or ParameterRef)</p> <code>None</code> <p>Use either <code>value</code> OR <code>inductance</code>, not both.</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Inductor(Component):\n    \"\"\"Indutor de 2 terminais; portas: a (positivo), b (negativo).\n\n    Args:\n        ref: Reference designator (e.g., \"1\" for L1)\n        value: Legacy stringly-typed value (backward compat)\n        inductance: Typed inductance value (float or ParameterRef)\n\n    Use either `value` OR `inductance`, not both.\n    \"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        value: str | float = \"\",\n        inductance: float | ParameterRef | None = None,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self.inductance = inductance\n        self._ports = (Port(self, \"a\", PortRole.POSITIVE), Port(self, \"b\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        a, b = self.ports\n        # Use typed field if present, otherwise fall back to value\n        val = str(self.inductance) if self.inductance is not None else self.value\n        return f\"L{self.ref} {net_of(a)} {net_of(b)} {val}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Ipulse","title":"<code>Ipulse</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de corrente PULSE(I1 I2 TD TR TF PW PER).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Ipulse(Component):\n    \"\"\"Fonte de corrente PULSE(I1 I2 TD TR TF PW PER).\"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        i1: str | float,\n        i2: str | float,\n        td: str | float,\n        tr: str | float,\n        tf: str | float,\n        pw: str | float,\n        per: str | float,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.i1, self.i2, self.td, self.tr, self.tf, self.pw, self.per = (\n            i1,\n            i2,\n            td,\n            tr,\n            tf,\n            pw,\n            per,\n        )\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return (\n            f\"I{self.ref} {net_of(p)} {net_of(n)} \"\n            f\"PULSE({self.i1} {self.i2} {self.td} {self.tr} {self.tf} {self.pw} {self.per})\"\n        )\n</code></pre>"},{"location":"reference/core/#spicelab.core.Ipwl","title":"<code>Ipwl</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de corrente PWL(args_raw).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Ipwl(Component):\n    \"\"\"Fonte de corrente PWL(args_raw).\"\"\"\n\n    def __init__(self, ref: str, args_raw: str) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.args_raw = args_raw\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return f\"I{self.ref} {net_of(p)} {net_of(n)} PWL({self.args_raw})\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Net","title":"<code>Net</code>  <code>dataclass</code>","text":"<p>Logical node. Name is optional and used for debug; '0' is reserved for GND.</p> Source code in <code>spicelab/core/net.py</code> <pre><code>@dataclass(frozen=True)\nclass Net:\n    \"\"\"Logical node. Name is optional and used for debug; '0' is reserved for GND.\"\"\"\n\n    name: str | None = None\n</code></pre>"},{"location":"reference/core/#spicelab.core.OpAmpIdeal","title":"<code>OpAmpIdeal</code>","text":"<p>               Bases: <code>Component</code></p> <p>Op-amp ideal de 3 pinos (inp, inn, out) modelado por VCVS de alto ganho.</p> <p>Carta: E out 0 inp inn  Source code in <code>spicelab/core/components.py</code> <pre><code>class OpAmpIdeal(Component):\n    \"\"\"Op-amp ideal de 3 pinos (inp, inn, out) modelado por VCVS de alto ganho.\n\n    Carta: E&lt;ref&gt; out 0 inp inn &lt;gain&gt;\n    \"\"\"\n\n    def __init__(self, ref: str, gain: str | float = 1e6) -&gt; None:\n        super().__init__(ref=ref, value=str(gain))\n        self._ports = (\n            Port(self, \"inp\", PortRole.POSITIVE),\n            Port(self, \"inn\", PortRole.NEGATIVE),\n            Port(self, \"out\", PortRole.POSITIVE),\n        )\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        inp, inn, out = self.ports\n        return f\"E{self.ref} {net_of(out)} 0 {net_of(inp)} {net_of(inn)} {self.value}\"\n</code></pre> <p>Include the core public API (Circuit, Component base types, net utilities).</p>"},{"location":"reference/core/#spicelab.core.Resistor","title":"<code>Resistor</code>","text":"<p>               Bases: <code>Component</code></p> <p>Resistor de 2 terminais; portas: a (positivo), b (negativo).</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>Reference designator (e.g., \"1\" for R1)</p> required <code>value</code> <code>str | float</code> <p>Legacy stringly-typed value (backward compat)</p> <code>''</code> <code>resistance</code> <code>float | ParameterRef | None</code> <p>Typed resistance value (float or ParameterRef)</p> <code>None</code> <p>Use either <code>value</code> OR <code>resistance</code>, not both.</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Resistor(Component):\n    \"\"\"Resistor de 2 terminais; portas: a (positivo), b (negativo).\n\n    Args:\n        ref: Reference designator (e.g., \"1\" for R1)\n        value: Legacy stringly-typed value (backward compat)\n        resistance: Typed resistance value (float or ParameterRef)\n\n    Use either `value` OR `resistance`, not both.\n    \"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        value: str | float = \"\",\n        resistance: float | ParameterRef | None = None,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self.resistance = resistance\n        self._ports = (Port(self, \"a\", PortRole.POSITIVE), Port(self, \"b\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        a, b = self.ports\n        # Use typed field if present, otherwise fall back to value\n        val = str(self.resistance) if self.resistance is not None else self.value\n        return f\"R{self.ref} {net_of(a)} {net_of(b)} {val}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Vdc","title":"<code>Vdc</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de tens\u00e3o DC; portas: p (positivo), n (negativo).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Vdc(Component):\n    \"\"\"Fonte de tens\u00e3o DC; portas: p (positivo), n (negativo).\"\"\"\n\n    def __init__(self, ref: str, value: str | float = \"\") -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        # Para DC, escrevemos o valor diretamente\n        return f\"V{self.ref} {net_of(p)} {net_of(n)} {self.value}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Vpulse","title":"<code>Vpulse</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de tens\u00e3o PULSE(V1 V2 TD TR TF PW PER).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Vpulse(Component):\n    \"\"\"Fonte de tens\u00e3o PULSE(V1 V2 TD TR TF PW PER).\"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        v1: str | float,\n        v2: str | float,\n        td: str | float,\n        tr: str | float,\n        tf: str | float,\n        pw: str | float,\n        per: str | float,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.v1, self.v2, self.td, self.tr, self.tf, self.pw, self.per = (\n            v1,\n            v2,\n            td,\n            tr,\n            tf,\n            pw,\n            per,\n        )\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return (\n            f\"V{self.ref} {net_of(p)} {net_of(n)} \"\n            f\"PULSE({self.v1} {self.v2} {self.td} {self.tr} {self.tf} {self.pw} {self.per})\"\n        )\n</code></pre>"},{"location":"reference/core/#spicelab.core.Vpwl","title":"<code>Vpwl</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de tens\u00e3o PWL(args_raw).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Vpwl(Component):\n    \"\"\"Fonte de tens\u00e3o PWL(args_raw).\"\"\"\n\n    def __init__(self, ref: str, args_raw: str) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.args_raw = args_raw\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return f\"V{self.ref} {net_of(p)} {net_of(n)} PWL({self.args_raw})\"\n</code></pre>"},{"location":"reference/core/#core-api","title":"Core API","text":"<p>This section will be populated by <code>mkdocstrings</code> from the <code>spicelab.core</code> package.</p> <p>Example:</p> <p>Logical circuit composed of components, nets and raw SPICE directives.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@dataclass\nclass Circuit:\n    \"\"\"Logical circuit composed of components, nets and raw SPICE directives.\"\"\"\n\n    name: str\n    _net_ids: dict[Net, int] = field(default_factory=dict, init=False)\n    _port_to_net: dict[Port, Net] = field(default_factory=dict, init=False)\n    _components: list[Component] = field(default_factory=list, init=False)\n    _directives: list[str] = field(default_factory=list, init=False)\n    # metadata captured when loading from existing netlists\n    _subckt_defs: dict[str, str] = field(default_factory=dict, init=False)\n    _subckt_instances: list[dict[str, object]] = field(default_factory=list, init=False)\n    _port_labels: dict[Port, str] = field(default_factory=dict, init=False)\n    # Union-Find for O(\u03b1(n)) net merging (M2 performance optimization)\n    _net_union: UnionFind[Net] = field(default_factory=UnionFind, init=False)\n    # Cache invalidation version counter\n    _cache_version: int = field(default=0, init=False)\n\n    # ----------------------------------------------------------------------------------\n    # Building blocks\n    # ----------------------------------------------------------------------------------\n    def add(self, *components: Component) -&gt; Circuit:\n        \"\"\"Append one or more components to the circuit.\"\"\"\n\n        self._components.extend(components)\n        return self\n\n    def add_directive(self, line: str) -&gt; Circuit:\n        \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n        self._directives.append(line.rstrip(\"\\n\"))\n        return self\n\n    def add_directive_once(self, line: str) -&gt; Circuit:\n        \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n        normalized = line.strip()\n        for existing in self._directives:\n            if existing.strip() == normalized:\n                return self\n        return self.add_directive(line)\n\n    def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n        \"\"\"Connect a port to another port or to a logical net.\n\n        Uses Union-Find for O(\u03b1(n)) amortized net merging (M2 optimization).\n        \"\"\"\n        self._invalidate_cache()\n\n        if isinstance(b, Port):\n            net_a = self._port_to_net.get(a)\n            net_b = self._port_to_net.get(b)\n\n            if net_a and net_b and net_a is not net_b:\n                # Merge using Union-Find: O(\u03b1(n)) instead of O(n)\n                # Ensure both nets are in union-find\n                if net_a not in self._net_union:\n                    is_named_a = getattr(net_a, \"name\", None) is not None\n                    self._net_union.make_set(net_a, net_a if is_named_a else None)\n                if net_b not in self._net_union:\n                    is_named_b = getattr(net_b, \"name\", None) is not None\n                    self._net_union.make_set(net_b, net_b if is_named_b else None)\n\n                # Prefer named net as canonical\n                prefer = None\n                if getattr(net_a, \"name\", None):\n                    prefer = net_a\n                elif getattr(net_b, \"name\", None):\n                    prefer = net_b\n\n                self._net_union.union(net_a, net_b, prefer=prefer)\n            else:\n                shared = net_a or net_b or Net()\n                self._port_to_net[a] = shared\n                self._port_to_net[b] = shared\n                # Register in union-find\n                if shared not in self._net_union:\n                    is_named = getattr(shared, \"name\", None) is not None\n                    self._net_union.make_set(shared, shared if is_named else None)\n            self._port_labels.pop(b, None)\n        else:\n            self._port_to_net[a] = b\n            # Register named net in union-find\n            if b not in self._net_union:\n                is_named = getattr(b, \"name\", None) is not None\n                self._net_union.make_set(b, b if is_named else None)\n        self._port_labels.pop(a, None)\n        return self\n\n    def _invalidate_cache(self) -&gt; None:\n        \"\"\"Invalidate cached properties when circuit is modified.\"\"\"\n        self._cache_version += 1\n        # Clear cached net IDs\n        self._net_ids.clear()\n\n    def connect_with_label(self, port: Port, net: Net, label: str | None = None) -&gt; Circuit:\n        \"\"\"Connect ``port`` to ``net`` while recording a display label.\"\"\"\n\n        self.connect(port, net)\n        if label:\n            self._port_labels[port] = label\n        return self\n\n    # ----------------------------------------------------------------------------------\n    # Net handling\n    # ----------------------------------------------------------------------------------\n    def _assign_node_ids(self) -&gt; None:\n        \"\"\"Assign node IDs, using Union-Find for canonical net resolution.\"\"\"\n        self._net_ids.clear()\n        self._net_ids[GND] = 0\n\n        next_id = 1\n        seen: set[Net] = {GND}\n\n        def canonical_nets_from_components() -&gt; Iterable[Net]:\n            for comp in self._components:\n                for port in comp.ports:\n                    net = self._port_to_net.get(port)\n                    if net is not None:\n                        # Use canonical net for proper merging\n                        yield self._get_canonical_net(net)\n\n        for net in canonical_nets_from_components():\n            if net in seen:\n                continue\n            seen.add(net)\n            if getattr(net, \"name\", None) and net.name != \"0\":\n                # preserve named nets but still assign an id for bookkeeping\n                self._net_ids[net] = next_id\n            else:\n                self._net_ids[net] = next_id\n            next_id += 1\n\n    def _net_of(self, port: Port) -&gt; str:\n        net = self._port_to_net.get(port)\n        if net is None:\n            raise ValueError(f\"Unconnected port: {port.owner.ref}.{port.name}\")\n\n        # Use Union-Find to get the canonical net (handles merged nets)\n        canonical_net = self._get_canonical_net(net)\n\n        if canonical_net is GND or getattr(canonical_net, \"name\", None) == \"0\":\n            return \"0\"\n\n        if getattr(canonical_net, \"name\", None):\n            return str(canonical_net.name)\n\n        node_id = self._net_ids.get(canonical_net)\n        if node_id is None:\n            raise RuntimeError(\"Node IDs not assigned\")\n        return str(node_id)\n\n    def _get_canonical_net(self, net: Net) -&gt; Net:\n        \"\"\"Get the canonical net for a possibly-merged net using Union-Find.\"\"\"\n        if net not in self._net_union:\n            return net\n        return self._net_union.get_canonical(net)\n\n    # ----------------------------------------------------------------------------------\n    # Netlist helpers\n    # ----------------------------------------------------------------------------------\n    def build_netlist(self) -&gt; str:\n        \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [f\"* {self.name}\"]\n\n        for comp in self._components:\n            card = comp.spice_card(self._net_of)\n            # components such as AnalogMux may emit multi-line cards\n            for ln in card.splitlines():\n                if ln.strip():\n                    lines.append(ln)\n\n        for directive in self._directives:\n            lines.extend(directive.splitlines())\n\n        if not any(line.strip().lower() == \".end\" for line in lines):\n            lines.append(\".end\")\n\n        return \"\\n\".join(lines) + \"\\n\"\n\n    def save_netlist(self, path: str | Path) -&gt; Path:\n        \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n        p = Path(path)\n        p.write_text(self.build_netlist(), encoding=\"utf-8\")\n        return p\n\n    # ----------------------------------------------------------------------------------\n    # Hash (deterministic) - part of M1 contract\n    # ----------------------------------------------------------------------------------\n    def hash(self, *, extra: dict[str, object] | None = None) -&gt; str:  # pragma: no cover - thin\n        \"\"\"Return a deterministic short hash for this circuit.\n\n        Wrapper around ``spicelab.core.types.circuit_hash`` so callers do not need\n        to import the helper directly. ``extra`` can include engine/version/analysis\n        args to bind caches firmly to execution context.\n        \"\"\"\n        from .types import circuit_hash  # local import to avoid cycle during module init\n\n        return circuit_hash(self, extra=extra)\n\n    # ----------------------------------------------------------------------------------\n    # Validation (M4 DX improvement)\n    # ----------------------------------------------------------------------------------\n    def validate(self, strict: bool = False) -&gt; ValidationResult:\n        \"\"\"Validate circuit topology and component values.\n\n        Performs checks:\n        - Ground reference exists\n        - No floating nodes (connected to only one component)\n        - No unusual component values\n        - No voltage source shorts (parallel voltage sources)\n\n        Args:\n            strict: If True, treat warnings as errors\n\n        Returns:\n            ValidationResult with errors and warnings\n\n        Example:\n            &gt;&gt;&gt; result = circuit.validate()\n            &gt;&gt;&gt; if result.has_issues():\n            ...     print(result)\n            &gt;&gt;&gt; if not result.is_valid:\n            ...     raise ValueError(\"Circuit has errors\")\n        \"\"\"\n        from ..validators.circuit_validation import validate_circuit\n\n        return validate_circuit(self, strict=strict)\n\n    # ----------------------------------------------------------------------------------\n    # Introspection helpers\n    # ----------------------------------------------------------------------------------\n    def _net_label(self, net: Net | None) -&gt; str:\n        if net is None:\n            return \"&lt;unconnected&gt;\"\n\n        # Use canonical net for merged nets\n        canonical = self._get_canonical_net(net)\n\n        if canonical is GND or getattr(canonical, \"name\", None) == \"0\":\n            return \"0\"\n        if getattr(canonical, \"name\", None):\n            return str(canonical.name)\n        node_id = self._net_ids.get(canonical)\n        if node_id is None:\n            self._assign_node_ids()\n            node_id = self._net_ids.get(canonical)\n        return f\"N{node_id:03d}\" if node_id is not None else \"&lt;unnamed&gt;\"\n\n    def summary(self) -&gt; str:\n        \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = []\n        warnings: list[str] = []\n\n        lines.append(f\"Circuit: {self.name}\")\n        lines.append(f\"Components ({len(self._components)}):\")\n\n        for comp in self._components:\n            port_descriptions: list[str] = []\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                label = self._port_labels.get(port) or self._net_label(net)\n                if label == \"&lt;unconnected&gt;\":\n                    warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n                port_descriptions.append(f\"{port.name}-&gt;{label}\")\n            port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n            lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n        net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n        if net_names:\n            lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n        if warnings:\n            lines.append(\"Warnings:\")\n            for msg in warnings:\n                lines.append(f\"  * {msg}\")\n        else:\n            lines.append(\"Warnings: none\")\n\n        return \"\\n\".join(lines)\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n        comp_ids: dict[Component, str] = {}\n        for idx, comp in enumerate(self._components, start=1):\n            comp_id = f\"comp_{idx}\"\n            comp_ids[comp] = comp_id\n            label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n            lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n        net_ids: dict[Net | None, str] = {}\n        net_counter = 1\n\n        def _net_node(net: Net | None) -&gt; str:\n            nonlocal net_counter\n            if net in net_ids:\n                return net_ids[net]\n            node_id = f\"net_{net_counter}\"\n            net_counter += 1\n            label = self._net_label(net)\n            shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n            net_ids[net] = node_id\n            lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n            return node_id\n\n        for comp in self._components:\n            comp_id = comp_ids[comp]\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                net_id = _net_node(net)\n                lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n        lines.append(\"}\")\n        return \"\\n\".join(lines)\n\n    # ----------------------------------------------------------------------------------\n    # Notebook-friendly helpers\n    # ----------------------------------------------------------------------------------\n    def connectivity_dataframe(self, *, sort: bool = True, include_type: bool = True):\n        \"\"\"Return a pandas DataFrame describing component/net connectivity.\n\n        Columns: ``component``, ``type`` (optional), ``port`` and ``net``. The\n        returned DataFrame is ideal for Jupyter notebooks where an interactive\n        table is easier to scan than the plain text summary.\n        \"\"\"\n\n        try:\n            import pandas as pd\n        except Exception as exc:  # pragma: no cover - optional dependency guard\n            raise RuntimeError(\"pandas is required for connectivity_dataframe()\") from exc\n\n        self._assign_node_ids()\n\n        rows: list[dict[str, object]] = []\n        for comp in self._components:\n            for order, port in enumerate(comp.ports):\n                net = self._port_to_net.get(port)\n                label = self._port_labels.get(port) or self._net_label(net)\n                rows.append(\n                    {\n                        \"component\": comp.ref,\n                        \"type\": type(comp).__name__,\n                        \"port\": port.name,\n                        \"net\": label,\n                        \"_order\": order,\n                    }\n                )\n\n        if not rows:\n            columns = [\"component\", \"port\", \"net\"]\n            if include_type:\n                columns.insert(1, \"type\")\n            return pd.DataFrame(columns=columns)\n\n        df = pd.DataFrame(rows)\n        if sort:\n            df = df.sort_values([\"component\", \"_order\", \"port\"]).reset_index(drop=True)\n        if not include_type:\n            df = df.drop(columns=[\"type\"])\n        return df.drop(columns=[\"_order\"])\n\n    def summary_table(self, *, indent: int = 2) -&gt; str:\n        \"\"\"Return a fixed-width table describing component connections.\"\"\"\n\n        df = self.connectivity_dataframe()\n        if df.empty:\n            return \"(circuit is empty)\"\n\n        headers = list(df.columns)\n        display_names = {col: col.capitalize() for col in headers}\n        widths = {\n            col: max(len(display_names[col]), *(len(str(val)) for val in df[col]))\n            for col in headers\n        }\n\n        def fmt_row(row: dict[str, object]) -&gt; str:\n            cells = [str(row[col]).ljust(widths[col]) for col in headers]\n            return \" \" * indent + \"  \".join(cells)\n\n        header_line = \" \" * indent + \"  \".join(\n            display_names[col].ljust(widths[col]) for col in headers\n        )\n        sep_line = \" \" * indent + \"  \".join(\"-\" * widths[col] for col in headers)\n        body = \"\\n\".join(fmt_row(df.iloc[idx]) for idx in range(len(df)))\n        return f\"{header_line}\\n{sep_line}\\n{body}\"\n\n    # ----------------------------------------------------------------------------------\n    # Netlist import\n    # ----------------------------------------------------------------------------------\n    @classmethod\n    def from_netlist(cls, path: str | Path) -&gt; Circuit:\n        \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n        p = Path(path)\n        text = p.read_text(encoding=\"utf-8\")\n\n        from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n        lines = preprocess_netlist(text)\n        ast = parse_lines_to_ast(lines)\n\n        name = p.stem\n        if lines and lines[0].lstrip().startswith(\"*\"):\n            maybe_title = lines[0].lstrip()[1:].strip()\n            if maybe_title:\n                name = maybe_title\n\n        circ = cls(name=name)\n\n        for node in ast:\n            kind_obj = node.get(\"type\")\n            kind = str(kind_obj) if isinstance(kind_obj, str) else None\n            raw_obj = node.get(\"raw\")\n            raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n            if kind == \"subckt\":\n                header = raw.splitlines()[0]\n                parts = header.split()\n                if len(parts) &gt;= 2:\n                    circ._subckt_defs[parts[1]] = raw\n                circ.add_directive(raw)\n                continue\n\n            if kind == \"comment\" or kind == \"directive\":\n                circ.add_directive(raw)\n                continue\n\n            if kind != \"component\":\n                continue\n\n            tokens_obj = node.get(\"tokens\")\n            tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n            if not tokens:\n                continue\n\n            card = tokens[0]\n            letter = cast(str | None, node.get(\"letter\"))\n            ref = cast(str | None, node.get(\"ref\"))\n\n            try:\n                comp = cls._component_from_tokens(letter, ref, tokens)\n                if comp is None:\n                    circ.add_directive(raw)\n                    continue\n                circ.add(comp)\n                circ._connect_from_tokens(comp, tokens[1:])\n                if letter == \"X\":\n                    circ._subckt_instances.append(\n                        {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                    )\n            except Exception as exc:  # pragma: no cover - defensive fallback\n                log.warning(\"Failed to parse component '%s': %s\", card, exc)\n                circ.add_directive(raw)\n\n        return circ\n\n    # ----------------------------------------------------------------------------------\n    # Helpers for from_netlist\n    # ----------------------------------------------------------------------------------\n    @staticmethod\n    def _component_from_tokens(\n        letter: str | None, ref: str | None, tokens: list[str]\n    ) -&gt; Component | None:\n        if not letter or not ref:\n            return None\n\n        letter = letter.upper()\n        value = \" \".join(tokens[3:]) if len(tokens) &gt; 3 else \"\"\n\n        if letter == \"R\":\n            return Resistor(ref=ref, value=value)\n        if letter == \"C\":\n            return Capacitor(ref=ref, value=value)\n        if letter == \"L\":\n            return Inductor(ref=ref, value=value)\n        if letter == \"V\":\n            return Vdc(ref=ref, value=value)\n        if letter == \"I\":\n            return Idc(ref=ref, value=value)\n        if letter == \"E\":\n            gain = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCVS(ref=ref, gain=gain)\n        if letter == \"G\":\n            gm = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCCS(ref=ref, gm=gm)\n        if letter == \"F\":\n            gain = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCCS(ref=ref, ctrl_vsrc=ctrl, gain=gain)\n        if letter == \"H\":\n            r = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCVS(ref=ref, ctrl_vsrc=ctrl, r=r)\n        if letter == \"D\":\n            model = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return Diode(ref=ref, model=model)\n        if letter == \"S\":\n            model = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VSwitch(ref=ref, model=model)\n        if letter == \"W\":\n            model = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return ISwitch(ref=ref, ctrl_vsrc=ctrl, model=model)\n\n        # Subcircuits and unsupported devices are preserved as directives\n        return None\n\n    def _connect_from_tokens(self, component: Component, node_tokens: list[str]) -&gt; None:\n        port_iter = iter(component.ports)\n        for node_name in node_tokens:\n            try:\n                port = next(port_iter)\n            except StopIteration:\n                break\n            net = self._get_or_create_net(node_name)\n            self.connect(port, net)\n\n    def _get_or_create_net(self, name: str) -&gt; Net:\n        if name == \"0\":\n            return GND\n        for net in self._port_to_net.values():\n            if getattr(net, \"name\", None) == name:\n                return net\n        new = Net(name)\n        return new\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.add","title":"<code>add(*components)</code>","text":"<p>Append one or more components to the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add(self, *components: Component) -&gt; Circuit:\n    \"\"\"Append one or more components to the circuit.\"\"\"\n\n    self._components.extend(components)\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.add_directive","title":"<code>add_directive(line)</code>","text":"<p>Append a raw SPICE directive (<code>.model</code>, <code>.param</code> ...).</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive(self, line: str) -&gt; Circuit:\n    \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n    self._directives.append(line.rstrip(\"\\n\"))\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.add_directive_once","title":"<code>add_directive_once(line)</code>","text":"<p>Add a directive if an identical line (ignoring whitespace) is absent.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive_once(self, line: str) -&gt; Circuit:\n    \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n    normalized = line.strip()\n    for existing in self._directives:\n        if existing.strip() == normalized:\n            return self\n    return self.add_directive(line)\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.build_netlist","title":"<code>build_netlist()</code>","text":"<p>Return a SPICE netlist representation of this circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def build_netlist(self) -&gt; str:\n    \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [f\"* {self.name}\"]\n\n    for comp in self._components:\n        card = comp.spice_card(self._net_of)\n        # components such as AnalogMux may emit multi-line cards\n        for ln in card.splitlines():\n            if ln.strip():\n                lines.append(ln)\n\n    for directive in self._directives:\n        lines.extend(directive.splitlines())\n\n    if not any(line.strip().lower() == \".end\" for line in lines):\n        lines.append(\".end\")\n\n    return \"\\n\".join(lines) + \"\\n\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.connect","title":"<code>connect(a, b)</code>","text":"<p>Connect a port to another port or to a logical net.</p> <p>Uses Union-Find for O(\u03b1(n)) amortized net merging (M2 optimization).</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n    \"\"\"Connect a port to another port or to a logical net.\n\n    Uses Union-Find for O(\u03b1(n)) amortized net merging (M2 optimization).\n    \"\"\"\n    self._invalidate_cache()\n\n    if isinstance(b, Port):\n        net_a = self._port_to_net.get(a)\n        net_b = self._port_to_net.get(b)\n\n        if net_a and net_b and net_a is not net_b:\n            # Merge using Union-Find: O(\u03b1(n)) instead of O(n)\n            # Ensure both nets are in union-find\n            if net_a not in self._net_union:\n                is_named_a = getattr(net_a, \"name\", None) is not None\n                self._net_union.make_set(net_a, net_a if is_named_a else None)\n            if net_b not in self._net_union:\n                is_named_b = getattr(net_b, \"name\", None) is not None\n                self._net_union.make_set(net_b, net_b if is_named_b else None)\n\n            # Prefer named net as canonical\n            prefer = None\n            if getattr(net_a, \"name\", None):\n                prefer = net_a\n            elif getattr(net_b, \"name\", None):\n                prefer = net_b\n\n            self._net_union.union(net_a, net_b, prefer=prefer)\n        else:\n            shared = net_a or net_b or Net()\n            self._port_to_net[a] = shared\n            self._port_to_net[b] = shared\n            # Register in union-find\n            if shared not in self._net_union:\n                is_named = getattr(shared, \"name\", None) is not None\n                self._net_union.make_set(shared, shared if is_named else None)\n        self._port_labels.pop(b, None)\n    else:\n        self._port_to_net[a] = b\n        # Register named net in union-find\n        if b not in self._net_union:\n            is_named = getattr(b, \"name\", None) is not None\n            self._net_union.make_set(b, b if is_named else None)\n    self._port_labels.pop(a, None)\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.connect_with_label","title":"<code>connect_with_label(port, net, label=None)</code>","text":"<p>Connect <code>port</code> to <code>net</code> while recording a display label.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connect_with_label(self, port: Port, net: Net, label: str | None = None) -&gt; Circuit:\n    \"\"\"Connect ``port`` to ``net`` while recording a display label.\"\"\"\n\n    self.connect(port, net)\n    if label:\n        self._port_labels[port] = label\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.connectivity_dataframe","title":"<code>connectivity_dataframe(*, sort=True, include_type=True)</code>","text":"<p>Return a pandas DataFrame describing component/net connectivity.</p> <p>Columns: <code>component</code>, <code>type</code> (optional), <code>port</code> and <code>net</code>. The returned DataFrame is ideal for Jupyter notebooks where an interactive table is easier to scan than the plain text summary.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connectivity_dataframe(self, *, sort: bool = True, include_type: bool = True):\n    \"\"\"Return a pandas DataFrame describing component/net connectivity.\n\n    Columns: ``component``, ``type`` (optional), ``port`` and ``net``. The\n    returned DataFrame is ideal for Jupyter notebooks where an interactive\n    table is easier to scan than the plain text summary.\n    \"\"\"\n\n    try:\n        import pandas as pd\n    except Exception as exc:  # pragma: no cover - optional dependency guard\n        raise RuntimeError(\"pandas is required for connectivity_dataframe()\") from exc\n\n    self._assign_node_ids()\n\n    rows: list[dict[str, object]] = []\n    for comp in self._components:\n        for order, port in enumerate(comp.ports):\n            net = self._port_to_net.get(port)\n            label = self._port_labels.get(port) or self._net_label(net)\n            rows.append(\n                {\n                    \"component\": comp.ref,\n                    \"type\": type(comp).__name__,\n                    \"port\": port.name,\n                    \"net\": label,\n                    \"_order\": order,\n                }\n            )\n\n    if not rows:\n        columns = [\"component\", \"port\", \"net\"]\n        if include_type:\n            columns.insert(1, \"type\")\n        return pd.DataFrame(columns=columns)\n\n    df = pd.DataFrame(rows)\n    if sort:\n        df = df.sort_values([\"component\", \"_order\", \"port\"]).reset_index(drop=True)\n    if not include_type:\n        df = df.drop(columns=[\"type\"])\n    return df.drop(columns=[\"_order\"])\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.from_netlist","title":"<code>from_netlist(path)</code>  <code>classmethod</code>","text":"<p>Load a circuit from a plain SPICE netlist file.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@classmethod\ndef from_netlist(cls, path: str | Path) -&gt; Circuit:\n    \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n    p = Path(path)\n    text = p.read_text(encoding=\"utf-8\")\n\n    from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n    lines = preprocess_netlist(text)\n    ast = parse_lines_to_ast(lines)\n\n    name = p.stem\n    if lines and lines[0].lstrip().startswith(\"*\"):\n        maybe_title = lines[0].lstrip()[1:].strip()\n        if maybe_title:\n            name = maybe_title\n\n    circ = cls(name=name)\n\n    for node in ast:\n        kind_obj = node.get(\"type\")\n        kind = str(kind_obj) if isinstance(kind_obj, str) else None\n        raw_obj = node.get(\"raw\")\n        raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n        if kind == \"subckt\":\n            header = raw.splitlines()[0]\n            parts = header.split()\n            if len(parts) &gt;= 2:\n                circ._subckt_defs[parts[1]] = raw\n            circ.add_directive(raw)\n            continue\n\n        if kind == \"comment\" or kind == \"directive\":\n            circ.add_directive(raw)\n            continue\n\n        if kind != \"component\":\n            continue\n\n        tokens_obj = node.get(\"tokens\")\n        tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n        if not tokens:\n            continue\n\n        card = tokens[0]\n        letter = cast(str | None, node.get(\"letter\"))\n        ref = cast(str | None, node.get(\"ref\"))\n\n        try:\n            comp = cls._component_from_tokens(letter, ref, tokens)\n            if comp is None:\n                circ.add_directive(raw)\n                continue\n            circ.add(comp)\n            circ._connect_from_tokens(comp, tokens[1:])\n            if letter == \"X\":\n                circ._subckt_instances.append(\n                    {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                )\n        except Exception as exc:  # pragma: no cover - defensive fallback\n            log.warning(\"Failed to parse component '%s': %s\", card, exc)\n            circ.add_directive(raw)\n\n    return circ\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.hash","title":"<code>hash(*, extra=None)</code>","text":"<p>Return a deterministic short hash for this circuit.</p> <p>Wrapper around <code>spicelab.core.types.circuit_hash</code> so callers do not need to import the helper directly. <code>extra</code> can include engine/version/analysis args to bind caches firmly to execution context.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def hash(self, *, extra: dict[str, object] | None = None) -&gt; str:  # pragma: no cover - thin\n    \"\"\"Return a deterministic short hash for this circuit.\n\n    Wrapper around ``spicelab.core.types.circuit_hash`` so callers do not need\n    to import the helper directly. ``extra`` can include engine/version/analysis\n    args to bind caches firmly to execution context.\n    \"\"\"\n    from .types import circuit_hash  # local import to avoid cycle during module init\n\n    return circuit_hash(self, extra=extra)\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.save_netlist","title":"<code>save_netlist(path)</code>","text":"<p>Persist the netlist to <code>path</code> and return the resolved <code>Path</code>.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def save_netlist(self, path: str | Path) -&gt; Path:\n    \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n    p = Path(path)\n    p.write_text(self.build_netlist(), encoding=\"utf-8\")\n    return p\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of the circuit and connectivity.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def summary(self) -&gt; str:\n    \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = []\n    warnings: list[str] = []\n\n    lines.append(f\"Circuit: {self.name}\")\n    lines.append(f\"Components ({len(self._components)}):\")\n\n    for comp in self._components:\n        port_descriptions: list[str] = []\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            label = self._port_labels.get(port) or self._net_label(net)\n            if label == \"&lt;unconnected&gt;\":\n                warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n            port_descriptions.append(f\"{port.name}-&gt;{label}\")\n        port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n        lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n    net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n    if net_names:\n        lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n    if warnings:\n        lines.append(\"Warnings:\")\n        for msg in warnings:\n            lines.append(f\"  * {msg}\")\n    else:\n        lines.append(\"Warnings: none\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.summary_table","title":"<code>summary_table(*, indent=2)</code>","text":"<p>Return a fixed-width table describing component connections.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def summary_table(self, *, indent: int = 2) -&gt; str:\n    \"\"\"Return a fixed-width table describing component connections.\"\"\"\n\n    df = self.connectivity_dataframe()\n    if df.empty:\n        return \"(circuit is empty)\"\n\n    headers = list(df.columns)\n    display_names = {col: col.capitalize() for col in headers}\n    widths = {\n        col: max(len(display_names[col]), *(len(str(val)) for val in df[col]))\n        for col in headers\n    }\n\n    def fmt_row(row: dict[str, object]) -&gt; str:\n        cells = [str(row[col]).ljust(widths[col]) for col in headers]\n        return \" \" * indent + \"  \".join(cells)\n\n    header_line = \" \" * indent + \"  \".join(\n        display_names[col].ljust(widths[col]) for col in headers\n    )\n    sep_line = \" \" * indent + \"  \".join(\"-\" * widths[col] for col in headers)\n    body = \"\\n\".join(fmt_row(df.iloc[idx]) for idx in range(len(df)))\n    return f\"{header_line}\\n{sep_line}\\n{body}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.to_dot","title":"<code>to_dot()</code>","text":"<p>Return a Graphviz DOT representation of the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n    comp_ids: dict[Component, str] = {}\n    for idx, comp in enumerate(self._components, start=1):\n        comp_id = f\"comp_{idx}\"\n        comp_ids[comp] = comp_id\n        label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n        lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n    net_ids: dict[Net | None, str] = {}\n    net_counter = 1\n\n    def _net_node(net: Net | None) -&gt; str:\n        nonlocal net_counter\n        if net in net_ids:\n            return net_ids[net]\n        node_id = f\"net_{net_counter}\"\n        net_counter += 1\n        label = self._net_label(net)\n        shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n        net_ids[net] = node_id\n        lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n        return node_id\n\n    for comp in self._components:\n        comp_id = comp_ids[comp]\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            net_id = _net_node(net)\n            lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n    lines.append(\"}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.validate","title":"<code>validate(strict=False)</code>","text":"<p>Validate circuit topology and component values.</p> <p>Performs checks: - Ground reference exists - No floating nodes (connected to only one component) - No unusual component values - No voltage source shorts (parallel voltage sources)</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, treat warnings as errors</p> <code>False</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with errors and warnings</p> Example <p>result = circuit.validate() if result.has_issues(): ...     print(result) if not result.is_valid: ...     raise ValueError(\"Circuit has errors\")</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def validate(self, strict: bool = False) -&gt; ValidationResult:\n    \"\"\"Validate circuit topology and component values.\n\n    Performs checks:\n    - Ground reference exists\n    - No floating nodes (connected to only one component)\n    - No unusual component values\n    - No voltage source shorts (parallel voltage sources)\n\n    Args:\n        strict: If True, treat warnings as errors\n\n    Returns:\n        ValidationResult with errors and warnings\n\n    Example:\n        &gt;&gt;&gt; result = circuit.validate()\n        &gt;&gt;&gt; if result.has_issues():\n        ...     print(result)\n        &gt;&gt;&gt; if not result.is_valid:\n        ...     raise ValueError(\"Circuit has errors\")\n    \"\"\"\n    from ..validators.circuit_validation import validate_circuit\n\n    return validate_circuit(self, strict=strict)\n</code></pre>"},{"location":"reference/io/","title":"IO API","text":"<p>Unified I/O layer: parsing waveform outputs into <code>xarray.Dataset</code> objects.</p>"},{"location":"reference/io/#low-level-parsers","title":"Low-level Parsers","text":""},{"location":"reference/io/#spicelab.io.raw_reader.Trace","title":"<code>Trace</code>  <code>dataclass</code>","text":"<p>Um tra\u00e7o: nome, unidade (quando existir) e vetor de valores (np.ndarray).</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>@dataclass(frozen=True)\nclass Trace:\n    \"\"\"Um tra\u00e7o: nome, unidade (quando existir) e vetor de valores (np.ndarray).\"\"\"\n\n    name: str\n    unit: str | None\n    values: NDArray[Any]\n    _complex: NDArray[Any] | None = None  # apenas AC: vetor complex\n\n    def magnitude(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return cast(NDArray[Any], np.abs(self._complex))\n        return cast(NDArray[Any], np.abs(self.values))\n\n    def real(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return self._complex.real\n        return self.values\n\n    def imag(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return self._complex.imag\n        return np.zeros_like(self.values, dtype=float)\n\n    def phase_deg(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return np.angle(self._complex, deg=True)\n        return np.zeros_like(self.values, dtype=float)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.TraceSet","title":"<code>TraceSet</code>","text":"<p>Conjunto de tra\u00e7os indexado por nome. O primeiro tra\u00e7o \u00e9 o eixo X (time/freq).</p> Acesso <p>ts[\"V(out)\"] -&gt; Trace ts.x -&gt; Trace (primeira coluna) ts.names -&gt; lista de nomes ts.to_dataframe() -&gt; pandas.DataFrame (se pandas instalado)</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>class TraceSet:\n    \"\"\"\n    Conjunto de tra\u00e7os indexado por nome. O primeiro tra\u00e7o \u00e9 o eixo X (time/freq).\n\n    Acesso:\n        ts[\"V(out)\"] -&gt; Trace\n        ts.x -&gt; Trace (primeira coluna)\n        ts.names -&gt; lista de nomes\n        ts.to_dataframe() -&gt; pandas.DataFrame (se pandas instalado)\n    \"\"\"\n\n    def __init__(\n        self,\n        traces: list[Trace],\n        *,\n        meta: dict[str, Any] | None = None,\n    ) -&gt; None:\n        if not traces:\n            raise ValueError(\"TraceSet requires at least one trace\")\n        self._traces = traces\n        self._by_name: dict[str, Trace] = {t.name: t for t in traces}\n        self.meta: dict[str, Any] = meta or {}\n\n        # valida tamanhos\n        n = len(self._traces[0].values)\n        for t in self._traces[1:]:\n            if len(t.values) != n:\n                raise ValueError(\"All traces must have same length\")\n\n    @property\n    def x(self) -&gt; Trace:\n        return self._traces[0]\n\n    @property\n    def names(self) -&gt; list[str]:\n        return [t.name for t in self._traces]\n\n    def __getitem__(self, key: str) -&gt; Trace:\n        try:\n            return self._by_name[key]\n        except KeyError as e:\n            raise KeyError(f\"Trace '{key}' not found. Available: {self.names}\") from e\n\n    def to_dataframe(self) -&gt; Any:\n        # Evita depender de stubs do pandas: import din\u00e2mico via importlib, tipado como Any\n        try:\n            pd: Any = importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\"pandas is required for to_dataframe()\") from exc\n        data = {t.name: t.values for t in self._traces}\n        return pd.DataFrame(data)\n\n    @classmethod\n    def from_dataset(cls, dataset: Any) -&gt; TraceSet:\n        \"\"\"Build a TraceSet from an xarray.Dataset-like object.\"\"\"\n\n        try:\n            import numpy as _np\n        except Exception as exc:  # pragma: no cover - numpy optional\n            raise RuntimeError(\"numpy is required to convert dataset into TraceSet\") from exc\n\n        if not hasattr(dataset, \"data_vars\"):\n            raise TypeError(\"Expected an xarray.Dataset-like object with 'data_vars'\")\n\n        coords = getattr(dataset, \"coords\", {})\n        coord_names = (\"time\", \"freq\", \"frequency\", \"index\")\n        coord_obj = None\n        coord_key = None\n        for name in coord_names:\n            if name in coords:\n                coord_obj = coords[name]\n                coord_key = name\n                break\n        if coord_obj is not None:\n            x_values = _np.asarray(getattr(coord_obj, \"values\", coord_obj), dtype=float)\n            x_name = str(getattr(coord_obj, \"name\", None) or coord_key or \"index\")\n        else:\n            data_vars = list(getattr(dataset, \"data_vars\", {}))\n            if not data_vars:\n                raise ValueError(\"Dataset has no data variables to build TraceSet\")\n            first = _np.asarray(dataset[data_vars[0]].values)\n            length = first.shape[0] if first.ndim &gt; 0 else 1\n            x_values = _np.arange(length, dtype=float)\n            x_name = \"index\"\n\n        x_values = _np.asarray(x_values, dtype=float).reshape(-1)\n        axis_len = x_values.shape[0]\n        traces: list[Trace] = [Trace(x_name, None, x_values)]\n\n        for name, data in getattr(dataset, \"data_vars\", {}).items():\n            arr = _np.asarray(data.values)\n            if arr.ndim == 0:\n                arr = _np.full((axis_len,), float(arr))\n            elif arr.shape[0] != axis_len:\n                try:\n                    arr = arr.reshape(axis_len, -1)\n                    arr = arr[:, 0]\n                except Exception as exc:  # pragma: no cover - defensive reshape\n                    raise ValueError(\n                        f\"Unable to align data variable '{name}' with independent axis\"\n                    ) from exc\n            else:\n                arr = arr.reshape(axis_len)\n            arr = _np.real_if_close(arr)\n            traces.append(Trace(str(name), None, _np.asarray(arr)))\n\n        meta = dict(getattr(dataset, \"attrs\", {}))\n        return cls(traces, meta=meta)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.TraceSet.from_dataset","title":"<code>from_dataset(dataset)</code>  <code>classmethod</code>","text":"<p>Build a TraceSet from an xarray.Dataset-like object.</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>@classmethod\ndef from_dataset(cls, dataset: Any) -&gt; TraceSet:\n    \"\"\"Build a TraceSet from an xarray.Dataset-like object.\"\"\"\n\n    try:\n        import numpy as _np\n    except Exception as exc:  # pragma: no cover - numpy optional\n        raise RuntimeError(\"numpy is required to convert dataset into TraceSet\") from exc\n\n    if not hasattr(dataset, \"data_vars\"):\n        raise TypeError(\"Expected an xarray.Dataset-like object with 'data_vars'\")\n\n    coords = getattr(dataset, \"coords\", {})\n    coord_names = (\"time\", \"freq\", \"frequency\", \"index\")\n    coord_obj = None\n    coord_key = None\n    for name in coord_names:\n        if name in coords:\n            coord_obj = coords[name]\n            coord_key = name\n            break\n    if coord_obj is not None:\n        x_values = _np.asarray(getattr(coord_obj, \"values\", coord_obj), dtype=float)\n        x_name = str(getattr(coord_obj, \"name\", None) or coord_key or \"index\")\n    else:\n        data_vars = list(getattr(dataset, \"data_vars\", {}))\n        if not data_vars:\n            raise ValueError(\"Dataset has no data variables to build TraceSet\")\n        first = _np.asarray(dataset[data_vars[0]].values)\n        length = first.shape[0] if first.ndim &gt; 0 else 1\n        x_values = _np.arange(length, dtype=float)\n        x_name = \"index\"\n\n    x_values = _np.asarray(x_values, dtype=float).reshape(-1)\n    axis_len = x_values.shape[0]\n    traces: list[Trace] = [Trace(x_name, None, x_values)]\n\n    for name, data in getattr(dataset, \"data_vars\", {}).items():\n        arr = _np.asarray(data.values)\n        if arr.ndim == 0:\n            arr = _np.full((axis_len,), float(arr))\n        elif arr.shape[0] != axis_len:\n            try:\n                arr = arr.reshape(axis_len, -1)\n                arr = arr[:, 0]\n            except Exception as exc:  # pragma: no cover - defensive reshape\n                raise ValueError(\n                    f\"Unable to align data variable '{name}' with independent axis\"\n                ) from exc\n        else:\n            arr = arr.reshape(axis_len)\n        arr = _np.real_if_close(arr)\n        traces.append(Trace(str(name), None, _np.asarray(arr)))\n\n    meta = dict(getattr(dataset, \"attrs\", {}))\n    return cls(traces, meta=meta)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.parse_ngspice_ascii_raw","title":"<code>parse_ngspice_ascii_raw(path)</code>","text":"<p>Parser robusto para NGSpice ASCII RAW.</p> <p>Retorna TraceSet onde a primeira coluna \u00e9 o eixo X (tipicamente 'time' ou 'frequency').</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>def parse_ngspice_ascii_raw(path: str) -&gt; TraceSet:\n    \"\"\"\n    Parser robusto para NGSpice ASCII RAW.\n\n    Retorna TraceSet onde a primeira coluna \u00e9 o eixo X (tipicamente 'time' ou 'frequency').\n    \"\"\"\n    with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n        lines = f.read().splitlines()\n\n    meta, i0 = _parse_header(lines)\n    nvars = int(meta[\"nvars\"])\n    npoints = int(meta[\"npoints\"])\n    vars_meta, i1 = _parse_variables(lines, i0, nvars)\n    data, complex_cols = _parse_values(lines, i1, nvars, npoints)\n\n    traces: list[Trace] = []\n    for j, (name, unit) in enumerate(vars_meta):\n        traces.append(\n            Trace(\n                name=name,\n                unit=unit,\n                values=data[:, j].copy(),\n                _complex=complex_cols[j],\n            )\n        )\n    return TraceSet(traces, meta=meta)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.parse_ngspice_ascii_raw_multi","title":"<code>parse_ngspice_ascii_raw_multi(path)</code>","text":"<p>L\u00ea um arquivo ASCII com m\u00faltiplos plots (p.ex. .step nativo) e retorna uma lista de TraceSet (um por bloco).</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>def parse_ngspice_ascii_raw_multi(path: str) -&gt; list[TraceSet]:\n    \"\"\"\n    L\u00ea um arquivo ASCII com m\u00faltiplos plots (p.ex. .step nativo) e retorna\n    uma lista de TraceSet (um por bloco).\n    \"\"\"\n    with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n        lines = f.read().splitlines()\n\n    i = 0\n    out: list[TraceSet] = []\n    while i &lt; len(lines):\n        # procurar in\u00edcio de um bloco (Title:/Plotname:/Variables:)\n        # Reutiliza as fun\u00e7\u00f5es privadas para cada bloco\n        # pular linhas vazias\n        while i &lt; len(lines) and not lines[i].strip():\n            i += 1\n        if i &gt;= len(lines):\n            break\n        # precisa ver se h\u00e1 um cabe\u00e7alho v\u00e1lido\n        try:\n            meta, i0 = _parse_header(lines[i:])\n            nvars = int(meta[\"nvars\"])\n            npoints = int(meta[\"npoints\"])\n            vars_meta, i1 = _parse_variables(lines[i:], i0, nvars)\n            data, complex_cols = _parse_values(lines[i:], i1, nvars, npoints)\n        except Exception:\n            # se n\u00e3o conseguiu, avan\u00e7a uma linha e tenta de novo\n            i += 1\n            continue\n\n        traces: list[Trace] = []\n        for j, (name, unit) in enumerate(vars_meta):\n            traces.append(\n                Trace(name=name, unit=unit, values=data[:, j].copy(), _complex=complex_cols[j])\n            )\n        out.append(TraceSet(traces, meta=meta))\n        # avan\u00e7ar: i += i1 + npoints ... mas j\u00e1 usamos slices; ent\u00e3o mova i para frente\n        # tenta achar pr\u00f3ximo 'Title:' ap\u00f3s o bloco atual\n        # heur\u00edstica simples: move i at\u00e9 encontrar pr\u00f3xima 'Title:' ou EOF\n        k = i + i1 + npoints + 4  # + margem\n        i = max(i + 1, k)\n    return out\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.parse_ngspice_raw","title":"<code>parse_ngspice_raw(path)</code>","text":"<p>Dispatcher para RAW ASCII ou bin\u00e1rio.</p> <p>Suporta formato bin\u00e1rio de linha simples (LTspice/NGSpice) para casos reais e complexos.</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>def parse_ngspice_raw(path: str) -&gt; TraceSet:\n    \"\"\"Dispatcher para RAW ASCII ou bin\u00e1rio.\n\n    Suporta formato bin\u00e1rio de linha simples (LTspice/NGSpice) para casos reais e complexos.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        blob = f.read()\n    # Heur\u00edsticas:\n    # 1. ASCII header: cont\u00e9m 'Binary:' sem null interleaving.\n    # 2. UTF-16 (wide) header: cont\u00e9m padr\u00e3o intercalado\n    #    B\\x00i\\x00n\\x00a... ou grande densidade de nulls.\n    head_scan = blob[:8192]\n    wide_pattern = b\"B\\x00i\\x00n\\x00a\\x00r\\x00y\\x00:\\x00\"\n    is_ascii_binary = b\"Binary:\" in head_scan or b\"binary\" in head_scan.lower()\n    is_wide_binary = wide_pattern in head_scan\n\n    if is_ascii_binary:\n        meta, data_bytes = _parse_binary_header_and_data(blob)\n        return _parse_binary_payload(meta, data_bytes)\n    if is_wide_binary:\n        # Localizar fim da linha 'Binary:' (padr\u00e3o newline UTF-16 '\\n\\x00')\n        marker_pos = head_scan.find(wide_pattern)\n        newline_pat = b\"\\n\\x00\"\n        nl_pos = head_scan.find(newline_pat, marker_pos)\n        if nl_pos == -1:\n            raise ValueError(\"UTF-16 binary RAW: newline after Binary: not found\")\n        header_bytes = blob[: nl_pos + 2]\n        # Remover nulls para obter texto ascii simplificado\n        ascii_header = header_bytes[::2].decode(\"utf-8\", errors=\"ignore\")\n        # Reaproveitar parser ascii-binary: reconstruir bytes artificiais com ascii header e newline\n        rebuilt = ascii_header.encode(\"utf-8\") + blob[nl_pos + 2 :]\n        meta, data_bytes = _parse_binary_header_and_data(rebuilt)\n        return _parse_binary_payload(meta, data_bytes)\n    # caso contr\u00e1rio tratar como ASCII\n    return parse_ngspice_ascii_raw(path)\n</code></pre>"},{"location":"reference/io/#unified-readers-facade","title":"Unified Readers Facade","text":"<p>High-level fa\u00e7ade returning an xarray.Dataset enriched with metadata.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>waveform file (.raw/.prn/.csv)</p> required <code>engine</code> <code>str | None</code> <p>optional explicit engine name (ngspice|ltspice|xyce)</p> <code>None</code> <code>log</code> <code>str | Path | None</code> <p>optional ngspice log path to extract version/warnings/errors</p> <code>None</code> <code>netlist_hash</code> <code>str | None</code> <p>deterministic hash of circuit/netlist (for provenance)</p> <code>None</code> <code>analysis_args</code> <code>dict[str, object] | None</code> <p>dict of analysis parameters used in run</p> <code>None</code> <code>allow_binary</code> <code>bool</code> <p>if False and RAW detected as binary, raise with guidance</p> <code>False</code> <code>complex_components</code> <code>bool | tuple[str, ...] | list[str] | None</code> <p>True or iterable specifying which complex parts to expand (e.g. True \u2192 (\"real\",\"imag\"), or (\"real\",\"imag\",\"phase\"))</p> <code>None</code> Source code in <code>spicelab/io/readers.py</code> <pre><code>def load_dataset(\n    path: str | Path,\n    *,\n    engine: str | None = None,\n    log: str | Path | None = None,\n    netlist_hash: str | None = None,\n    analysis_args: dict[str, object] | None = None,\n    allow_binary: bool = False,\n    complex_components: bool | tuple[str, ...] | list[str] | None = None,\n) -&gt; Any:\n    \"\"\"High-level fa\u00e7ade returning an xarray.Dataset enriched with metadata.\n\n    Parameters:\n        path: waveform file (.raw/.prn/.csv)\n        engine: optional explicit engine name (ngspice|ltspice|xyce)\n        log: optional ngspice log path to extract version/warnings/errors\n        netlist_hash: deterministic hash of circuit/netlist (for provenance)\n        analysis_args: dict of analysis parameters used in run\n        allow_binary: if False and RAW detected as binary, raise with guidance\n        complex_components: True or iterable specifying which complex parts to expand\n            (e.g. True \u2192 (\"real\",\"imag\"), or (\"real\",\"imag\",\"phase\"))\n    \"\"\"\n\n    p = Path(path)\n    include_complex: tuple[str, ...] | None = None\n    if complex_components:\n        if complex_components is True:\n            include_complex = (\"real\", \"imag\")\n        elif isinstance(complex_components, list | tuple):\n            include_complex = tuple(str(c).lower() for c in complex_components)\n        else:  # unexpected truthy\n            include_complex = (\"real\", \"imag\")\n\n    ds = read_waveform(\n        p,\n        engine_hint=engine,\n        allow_binary=allow_binary,\n        include_complex=include_complex,\n    )\n    if engine:\n        ds.attrs[\"engine\"] = engine\n    # Enrich with log summary if ngspice\n    if log is not None and (\n        engine == \"ngspice\" or (engine is None and ds.attrs.get(\"engine\") == \"ngspice\")\n    ):\n        summary = read_ngspice_log(log)\n        if summary.version:\n            ds.attrs.setdefault(\"engine_version\", summary.version)\n        if summary.warnings:\n            ds.attrs.setdefault(\"log_warnings\", summary.warnings)\n        if summary.errors:\n            ds.attrs.setdefault(\"log_errors\", summary.errors)\n    if netlist_hash:\n        ds.attrs.setdefault(\"netlist_hash\", netlist_hash)\n    if analysis_args:\n        ds.attrs.setdefault(\"analysis_args\", analysis_args)\n    # Infer version for other engines if not set\n    eng = ds.attrs.get(\"engine\")\n    if eng and \"engine_version\" not in ds.attrs:\n        ver = _infer_engine_version(eng, p)\n        if ver:\n            ds.attrs[\"engine_version\"] = ver\n    # Additional derived metadata\n    if \"engine\" in ds.attrs and \"analysis\" in ds.attrs:\n        ds.attrs.setdefault(\"provenance\", json.dumps({\"loaded_at\": datetime.utcnow().isoformat()}))\n    # Count points\n    try:\n        ds.attrs.setdefault(\"n_points\", int(ds.dims.get(\"index\", 0)))\n    except Exception:\n        pass\n    ds = normalize_dataset(ds)\n    return ds\n</code></pre> Source code in <code>spicelab/io/readers.py</code> <pre><code>def read_waveform(\n    path: str | Path,\n    engine_hint: str | None = None,\n    allow_binary: bool = True,\n    include_complex: tuple[str, ...] | None = None,\n) -&gt; Any:  # alias\n    return read(\n        path, engine_hint=engine_hint, allow_binary=allow_binary, include_complex=include_complex\n    )\n</code></pre> Source code in <code>spicelab/io/readers.py</code> <pre><code>def read_ngspice_raw(path: str | Path, *, include_complex: tuple[str, ...] | None = None) -&gt; Any:\n    ts = parse_ngspice_raw(str(path))\n    # parse single plot only; multi handled by read_ngspice_raw_multi\n    # meta inference only available on ascii for now\n    analysis = None\n    try:\n        # parse header manually for plotname\n        with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n            for ln in f:\n                if ln.lower().startswith(\"plotname:\"):\n                    analysis = _infer_analysis_from_plot(ln.split(\":\", 1)[1].strip())\n                    break\n    except Exception:\n        pass\n    # Fallback: if still unknown, attempt to use TraceSet meta (works for binary path)\n    if analysis is None:\n        meta = getattr(ts, \"meta\", None)\n        if isinstance(meta, dict):  # defensive\n            analysis = _infer_analysis_from_plot(meta.get(\"plotname\"))\n    return _to_xarray_from_traceset(\n        ts,\n        engine=\"ngspice\",\n        analysis=analysis,\n        raw_path=str(path),\n        meta=getattr(ts, \"meta\", None),\n        include_complex=include_complex,\n    )\n</code></pre> Source code in <code>spicelab/io/readers.py</code> <pre><code>def read_ngspice_raw_multi(\n    path: str | Path, *, include_complex: tuple[str, ...] | None = None\n) -&gt; Any:\n    tsets = parse_ngspice_ascii_raw_multi(str(path))\n    if not tsets:\n        raise ValueError(\"No plots found in RAW file\")\n    datasets: list[Any] = []\n    for idx, ts in enumerate(tsets):\n        ds = _to_xarray_from_traceset(\n            ts,\n            engine=\"ngspice\",\n            analysis=None,\n            raw_path=str(path),\n            stepped=True,\n            step_index=idx,\n            total_steps=len(tsets),\n            meta=getattr(ts, \"meta\", None),\n            include_complex=include_complex,\n        )\n        datasets.append(ds)\n    if len(datasets) == 1:\n        return datasets[0]\n    merged = _merge_steps(datasets, coord_name=\"step\")\n    merged.attrs.update(datasets[0].attrs)\n    return merged\n</code></pre> Source code in <code>spicelab/io/readers.py</code> <pre><code>def read_xyce_prn(path: str | Path) -&gt; Any:\n    return read_xyce_table(path)\n</code></pre> Source code in <code>spicelab/io/readers.py</code> <pre><code>def read_ltspice_raw(path: str | Path, *, include_complex: tuple[str, ...] | None = None) -&gt; Any:\n    # Reuse ngspice RAW parser (ASCII ou bin\u00e1rio compat\u00edvel simples)\n    ds = read_ngspice_raw(path, include_complex=include_complex)\n    # Adjust engine attr if heuristic suggests LTspice (presence of 'ltspice' in meta title)\n    try:\n        title = ds.attrs.get(\"title\") or ds.attrs.get(\"plot_title\")\n        command = ds.attrs.get(\"command\")\n        if (title and \"ltspice\" in str(title).lower()) or (\n            command and \"ltspice\" in str(command).lower()\n        ):\n            ds.attrs[\"engine\"] = \"ltspice\"\n    except Exception:  # pragma: no cover\n        pass\n    return ds\n</code></pre>"},{"location":"reference/io/#normalization-helpers","title":"Normalization &amp; Helpers","text":"<p>Apply post-load normalization (idempotent).</p> <ul> <li>Ensures signal names are canonical V(...)/I(...)</li> <li>Re-derives time/freq coordinate if missing and an alias column exists</li> </ul> Source code in <code>spicelab/io/readers.py</code> <pre><code>def normalize_dataset(ds: Any) -&gt; Any:\n    \"\"\"Apply post-load normalization (idempotent).\n\n    - Ensures signal names are canonical V(...)/I(...)\n    - Re-derives time/freq coordinate if missing and an alias column exists\n    \"\"\"\n    # If time coord absent, search for possible alias in data_vars\n    if \"time\" not in ds.coords:\n        for alias in _TIME_ALIASES:\n            if alias in ds.data_vars:\n                ds = ds.assign_coords({\"time\": (\"index\", ds[alias].values)})\n                break\n    if \"freq\" not in ds.coords:\n        for alias in _FREQ_ALIASES:\n            if alias in ds.data_vars:\n                ds = ds.assign_coords({\"freq\": (\"index\", ds[alias].values)})\n                break\n    return ds\n</code></pre> <p>Return a <code>pandas.DataFrame</code> with coords as columns (time/freq/step first).</p> Source code in <code>spicelab/io/readers.py</code> <pre><code>def to_pandas(ds: Any) -&gt; Any:\n    \"\"\"Return a `pandas.DataFrame` with coords as columns (time/freq/step first).\"\"\"\n    try:\n        pd = importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\"pandas is required for to_pandas(); pip install pandas\") from exc\n    data: dict[str, Any] = {}\n    order: list[str] = []\n    for special in (\"time\", \"freq\", \"step\"):\n        if special in ds.coords:\n            order.append(special)\n    for c in ds.coords:\n        if c not in order and c != \"index\":\n            order.append(c)\n    for c in order:\n        data[c] = ds[c].values\n    for name in sorted(ds.data_vars):\n        data[name] = ds[name].values\n    return pd.DataFrame(data)\n</code></pre> <p>Return a <code>polars.DataFrame</code> with coordinates lifted to columns.</p> Columns order heuristic <ol> <li>time or freq if present</li> <li>step (if present)</li> <li>remaining coords</li> <li>data variables (sorted)</li> </ol> Source code in <code>spicelab/io/readers.py</code> <pre><code>def to_polars(ds: Any) -&gt; Any:\n    \"\"\"Return a `polars.DataFrame` with coordinates lifted to columns.\n\n    Columns order heuristic:\n      1. time or freq if present\n      2. step (if present)\n      3. remaining coords\n      4. data variables (sorted)\n    \"\"\"\n    try:\n        pl = importlib.import_module(\"polars\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\"polars is required for to_polars(); pip install polars\") from exc\n    cols: dict[str, Iterable[Any]] = {}\n    # Collect coordinate-like columns\n    coord_order: list[str] = []\n    for special in (\"time\", \"freq\", \"step\"):\n        if special in ds.coords:\n            coord_order.append(special)\n    # Include other 1D coords (excluding index)\n    for c in ds.coords:\n        if c not in coord_order and c != \"index\":\n            coord_order.append(c)\n    # Add coordinate values\n    for c in coord_order:\n        cols[c] = ds[c].values.tolist()\n    # Data variables\n    for name in sorted(ds.data_vars):\n        cols[name] = ds[name].values.tolist()\n    return pl.DataFrame(cols)\n</code></pre> <p>Return a melted (long form) polars DataFrame: coord columns + name/value.</p> Source code in <code>spicelab/io/readers.py</code> <pre><code>def dataset_to_long_polars(ds: Any) -&gt; Any:\n    \"\"\"Return a melted (long form) polars DataFrame: coord columns + name/value.\"\"\"\n    wide = to_polars(ds)\n    coord_cols = [c for c in (\"time\", \"freq\", \"step\") if c in wide.columns]\n    id_vars = coord_cols\n    value_vars = [c for c in wide.columns if c not in id_vars]\n    long = wide.unpivot(on=value_vars, index=id_vars, variable_name=\"signal\", value_name=\"value\")\n    return long\n</code></pre> <p>Persist dataset to disk in selected format (netcdf|zarr|parquet).</p> Source code in <code>spicelab/io/readers.py</code> <pre><code>def save_dataset(ds: Any, path: str | Path, *, format: str = \"netcdf\") -&gt; Path:\n    \"\"\"Persist dataset to disk in selected format (netcdf|zarr|parquet).\"\"\"\n    xr = _require_xarray()\n    p = Path(path)\n    fmt = format.lower()\n    if fmt == \"netcdf\":\n        xr.decode_cf(ds).to_netcdf(p)\n    elif fmt == \"zarr\":  # pragma: no cover - optional\n        ds.to_zarr(p, mode=\"w\")\n    elif fmt == \"parquet\":\n        # Use long-form for parquet friendliness\n        long_df = dataset_to_long_polars(ds)\n        long_df.write_parquet(p)\n    else:  # pragma: no cover\n        raise ValueError(\"Unsupported format; choose netcdf|zarr|parquet\")\n    return p\n</code></pre> Source code in <code>spicelab/io/readers.py</code> <pre><code>def load_saved_dataset(path: str | Path) -&gt; Any:\n    p = Path(path)\n    xr = _require_xarray()\n    ext = p.suffix.lower()\n    if ext in {\".nc\", \".netcdf\"}:\n        return xr.load_dataset(p)\n    if ext == \".zarr\":  # pragma: no cover\n        return xr.open_zarr(p)\n    if ext == \".parquet\":\n        pl = importlib.import_module(\"polars\")\n        df = pl.read_parquet(p)\n        # reconstruct minimal dataset (wide pivot)\n        if {\"signal\", \"value\"}.issubset(set(df.columns)):\n            # pivot back\n            coord_cols = [c for c in (\"time\", \"freq\", \"step\") if c in df.columns]\n            wide = df.pivot(values=\"value\", columns=\"signal\", index=coord_cols)\n            ds = _require_xarray().Dataset.from_dataframe(wide.to_pandas())\n            return ds\n        raise ValueError(\"Parquet file missing required columns 'signal' and 'value'\")\n    raise ValueError(\"Unsupported file extension for load_saved_dataset\")\n</code></pre> <p>Return a classification of signals in an xarray Dataset.</p> Categories <ul> <li>voltage: names starting with 'V('</li> <li>current: names starting with 'I(' (including device/subckt currents)</li> <li>other: remaining data variables</li> </ul> <p>The returned dict maps category -&gt; sorted list of variable names.</p> <p>Binary RAW parsing, UTF\u201116 header detection, complex AC component expansion (<code>complex_components</code>), device current normalization extensions (@R1[i] -&gt; I(R1), @M1[id] -&gt; Id(M1)), classification helpers &amp; persistence utilities are integrated; upcoming work will focus on refined engine version heuristics, noise/distortion ingestion, and coordinate indexing improvements.</p>"},{"location":"reference/io/#spicelab.io.readers.list_signals--example","title":"Example","text":"<p>from spicelab.io import load_dataset, list_signals  # doctest: +SKIP ds = load_dataset(\"example.raw\", allow_binary=True)  # doctest: +SKIP list_signals(ds)  # doctest: +SKIP {'voltage': ['V(out)'], 'current': ['I(R1)'], 'other': []}</p> Source code in <code>spicelab/io/readers.py</code> <pre><code>def list_signals(ds: Any) -&gt; dict[str, list[str]]:\n    \"\"\"Return a classification of signals in an xarray Dataset.\n\n    Categories:\n      - voltage: names starting with 'V('\n      - current: names starting with 'I(' (including device/subckt currents)\n      - other: remaining data variables\n\n    The returned dict maps category -&gt; sorted list of variable names.\n\n    Example\n    -------\n    &gt;&gt;&gt; from spicelab.io import load_dataset, list_signals  # doctest: +SKIP\n    &gt;&gt;&gt; ds = load_dataset(\"example.raw\", allow_binary=True)  # doctest: +SKIP\n    &gt;&gt;&gt; list_signals(ds)  # doctest: +SKIP\n    {'voltage': ['V(out)'], 'current': ['I(R1)'], 'other': []}\n    \"\"\"\n    volt: list[str] = []\n    curr: list[str] = []\n    other: list[str] = []\n    for name in ds.data_vars:\n        if name.startswith(\"V(\"):\n            volt.append(name)\n        elif name.startswith(\"I(\"):\n            curr.append(name)\n        else:\n            other.append(name)\n    return {\n        \"voltage\": sorted(volt),\n        \"current\": sorted(curr),\n        \"other\": sorted(other),\n    }\n</code></pre>"}]}